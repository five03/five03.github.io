{"pages":[],"posts":[{"title":"⑦Android开发-Activity（一）","text":"Activity的生命周期 | 启动Activity的方式 | Activity标题及状态栏操作 Activity负责Android应用的界面处理工作，用来显示用户界面，并处理用户交互。通常，一个界面对应一个Activity，每一个Android应用都需要有一个入口Activity，其名称可以由开发者自行定义，但需要在AndroidManifest.xml中配置，需要对应action和category。 每个Activity都可以启动另一个或多个Activity，而每一个被启动的Activity都可以向启动它的Activity返回一些信息。 实现Activity的时候一般继承自Activity，并实现OnCreate方法。Activity是Context的实现子类，能填写Context的地方可以使用XXXActivity.this 实现Activity跳转实现Activity跳转时，使用startActivity方法，表示启动一个Activity的页面，传入Intent对象。 12345678910111213141516171819public class MainActivity extends AppCompatActivity { private Button btn; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化 btn = findViewById(R.id.btn); btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { //页面跳转（当前页面，跳转页面） Intent intent = new Intent(MainActivity.this,NewActivity.class); startActivity(intent); } }); }} 注意： super.onCreate(savedInstancesState)；必须调用，否则就会出现异常。否则就会SuperNotCalledException（父类方法没有调用）。 在项目中定义的所有的Activity都需要在AndroidManifest.xml中进行注册。否则在使用到的时候，会报ActivityNotFoundException异常（have you declared this activity in your AndroidManifest.xml?） Android中定义的四大组件都需要在AndroidManifest.xml中注册。 Activity的生命周期运行态（Running）：Activity处于屏幕前最顶端，用户可见且获得焦点 暂停态（Paused）：Activity被置于后台，用户可见，但失去了焦点 停止态（Stopped）：Activity被新的Activity覆盖失去焦点，用户不可见。 终止态（Destroyed）：Activity被系统终止，资源被收回。 生命周期方法onCreate：创建Activity的实例对象的方法。 onStart：启动当前的Activity实例方法。 onResume：如果该方法执行，页面的实例就和用户进行交互。 onPause：如果该方法执行，页面就和用户不在交互，失去焦点。（页面任可见） onStop：页面和用户完全不可见。 onDestroy：销毁当前Activity的页面实例。 onRestart：将置于后台的应用程序的Activity重新显示在前台的时候被调用，一般会连续调用onStart—onResume 注： Activity的生命周期方法都是成对出现的 onCreate — onDestroy onStart — onStop onResume — onPause Activity的协同作用假设Activity A启动Activity B，其调用过程如下： Activity A执行onPause()方法，它失去焦点； Activity B依次执行onCreate（）、onStart()和onResume()方法，这时Activity B拥有了焦点，且用户可见； 然后，Activity A的onStop（）方法将被执行； 系统保留下Activity A的状态信息，并显示Activity B给用户，同时它也获得了用户焦点，可以与用户开始交互。 Activity的task以及Back Stack Task：一个由当执行某一个共同任务时与用户产生交互的多个Activity组成的集合 Back Stack：这些Activity按顺序放在一个栈中，这个栈就叫做 “Back Stack”，即 “返回栈”，也叫做Activity栈，它其实就是一种后进先出的栈结构。 每当启动一个新的Activity时，它会被放入返回栈中，并处于栈顶的位置。每当我们按下Back键或调用activity的finish()方法去销毁一个活动时，处于栈顶的Activity会出栈，这时前一个入栈的Activity就会重新处于栈顶的位置。系统总是会显示处于栈顶的Activity给用户。 启动Activity的两种方式直接启动Activity 调用startActivity方法（见上文） 带返回值启动Activity 使用startActivityForResult(Intent intent，int requestCode)方法来实现。在被启动的Activity中调用： 1234Intent data = new Intent();data.setData(Uri.parse(et.getText().toString)));setResult(RESULT_OK,data);finish(); //传回data中的数据 在源Activity中重写onActivityResult(int requestCode， int resultCode，Intent data)方法来获得返回值。 int requestCode和 intresultCode用来区分哪一个页面是使用带有返回值进行跳转而来的，返回值又是给定哪一个页面的，data表示返回值时携带的intent对象。 预览效果 完整代码 MainActivity 123456789101112131415161718192021222324252627282930313233public class MainActivity extends AppCompatActivity { protected static final int REQUEST_CODE = 10; private Button button; private TextView tv; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化 button = findViewById(R.id.main_btn); tv = findViewById(R.id.main_tv); //设置button的点击监听 button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { //new intent对象 Intent i = new Intent(MainActivity.this,NewActivity.class); //参数一：请求的intent对象 //参数二：请求码 startActivityForResult(i,REQUEST_CODE); } }); } @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) { super.onActivityResult(requestCode, resultCode, data); if(requestCode==REQUEST_CODE&amp;&amp;resultCode==RESULT_OK){ //显示返回值 tv.setText(data.getStringExtra(\"name\")); } }} NewActivity 12345678910111213141516171819202122232425public class NewActivity extends Activity { private Button btn; protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.new_activity); btn = findViewById(R.id.button); btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { //点击结束该Activity，并回传内容 Intent data = new Intent(); data.putExtra(\"name\",\"今天天气不错\"); //参数一：返回码 //参数二：intent对象 setResult(RESULT_OK,data); //结束页面 finish(); } }); }} Activity横竖屏变化Activity标题和状态栏操作改变标题 方法一：在&lt;Activity&gt;标签中使用android:label=&quot;...&quot;属性； 方法二：在onCreate()方法中使用setTitle()。 去除标题栏 方法一：在onCreate()方法中requestWindowFeature(Window.FEATURE_NO_TITLE);（须定义在setContentView()方法之前）； 方法二：在XML文件中添加，android:theme=&quot;@android:style/Theme.Light.NoTitleBar&quot;。 去掉状态栏（全屏显示） 方法一：在XML文件中添加，`android:theme=”@android:style/Theme.Light.NoTitleBar.Fullscreen” 方法二：在onCreate()方法中使用getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);。","link":"/2019/02/13/Android%E5%BC%80%E5%8F%91-Activity1/"},{"title":"⑧Android开发-Activity（二）","text":"Intent | Activity的启动模式 IntentIntent是一个可以消息传递对象，可以通过它来进行组件之间的信息传递。Intent主要有以下三个作用： 开启一个activity 开启一个service 发送广播消息 包含六大属性： Action：动作 Category：分类 Data：数据 ComponentName：组件名 Extra：额外的数据 Flag：标记 ComponentName（组件名）组件名用来处理Intent的匹配问题，它可以被设置，也可以不被设置。设置了组件名的Intent叫做显示Intent，这种Intent在匹配时将直接使用组件名里的参数 1234Intent intent = new Intent();ComponentName cn = new ComponentName(this,NewActivity.class);intent.setComponent(cn);startActivity(intent); 不设置组件名的Intent叫做隐式Intent，这种Intent在匹配时将会从Action、Data（URI和Type）或Category中寻找匹配信息。 Category（分类）一个含有Intent的附加信息的字符串，这些信息可以决定哪种组件应该处理这个Intent，进一步筛选到底需要处理的内容。 Category常量 含义 category_HOME 显示Home界面的Activity，可以使用这个常量来显示Home界面 category_LAUNCHER 位于一个作业的Activity栈栈底的Activity，是这个作业的初始Activity，一般就是一个应用的入口Activity category_DEFAULT 默认的，Android系统会给隐式Intent自动加上这个值（隐式启动） Category一般被设置在IntentFilter中，对于显示Intent，如果不指定Category，则无论IntentFilter的内容是什么都是匹配的。 Extra（额外的数据）Extras属性主要用于传递目标组件所需要的额外的数据。通过putExtra(键值对)键是字符串类型或putExtras()传递的是一个bundle类型对象，该对象可以放置很多数据。 Data（数据）Data属性包括两部分，URI（通过资源标识符）和Type（MIME类型）。常用的Data取值： Data取值 说明 示例 file:/// 本地文件数据，后接文件路径 file:///mnt/sdcard/mp3/a.mp3 mailto:// 电子邮件，后接收件人地址 mailto://xxx@163.com geo:// 地理位置信息，后接经纬度 geo://47.231810,-53.519061 smsto: 短信，后接目标号码 smsto:+86186xxx tel:// 短信，后接目标号码 tel://+86186xxx content:/// 内容，后接内容定位 content://contacts/people/1 http:// 超文本，后接网络资源的URI http://www.baidu.com Flag（标志）Flag属性多用于Task和Activity栈的处理中，可以通过不同的Flags告诉系统一个Activity属于哪个Task、一个Activity被启动或停止后在Activity栈中的位置如何改变等等。 Action（动作）描述Intent将要完成什么动作，为了区别当前的Intent对象进行使用，类型是StringAndroid.Intents.action.MAIN,这个值在每个AndroidManifest.xml文档中都可以看到，它标记当前Activity作为一个程序的入口。可以使用内置的Action与Data属性配合，来实现打电话、发短信、浏览网页等功能。 启动一个Activity一般有两种形式，分别是显示启动和隐式启动： 显示启动： 12Intent intent = new Intent(当前的activity.this,目标的Activity.class);startActivity(intent); 隐式启动： 如果需要实现隐式启动，一般使用action和data或者action和category结合。 action和category结合 1234Intent intent = new Intent();//设定Action动作intent.setAction(\"当前包名.MainActivity.action\");startActivity(intent); AndroidManifest.xml中定义action属性 123456&lt;activity android：name=\"包名.跳转的Activity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"包名.当前的Activity\"/&gt; &lt;category android:name=\"android.intent.category_DEFAULT\"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; action和data结合 当前页面 12345678brn.setOnClickListener(new View.OnClickListener(){ public void onClick(View v){ Intent intent = new Intent(当前的Activity.this,跳转的Activity.class); //将数据放入intent intent.put(\"info\",EditText.getText().toString()); startActivity(intent); }}); 跳转页面 123456//首先获取传递过来的intent对象if(getIntent()!=null){ Intent intent = getIntent(); String info = intent.getStringExtra(\"info\"); TextView.setText(info);} 注：如果数据量大的话可以使用bundle 1234Bundle bundle = new Bundle();bundle.putString(\"info\",EditText.getText().toString());intent.putExtras(bundle);startActivity(intent); 123456if(getIntent()!=null){ Intent intent = getIntent(); Bundle bundle = intent.getExtras(); String info = bundle.getString(\"info\",\"未接收到数据\"); TextView.setText(info);} 常见的系统内置Action Action常量 目标组件 动作 ACTION_CALL Activity 直接拨打Data属性指定的电话号码 ACTION_EDIT Activity 给用户显示可编辑的数据 ACTION_MAIN Activity 开启一个Activity并将其作为一个作业（Task）的初始Activity，并且不带输入和返回信息。通俗讲就是开启一个Activity并将其作为在应用的入口Activity。 ACTION_SYNC Activity 同步服务器上的数据和移动设备中的数据 ACTION_DIAL Activity 将Data中的电话号码放入拨打电话的界面中，显示给用户，供用户手动播出这个号码。 ACTION_VIEW Activity 使用与Data中数据相对应的应用程序来显示Data中指定的数据 ACTION_SEND Activity 发送数据 ACTION_SENDTO Activity 使用与Data中指定的数据相对应的应用，程序向Data中所指定的地址发送数据。 ACTION_BATTERY_LOW Broadcast Receiver 一个电池电量低的警告 ACTION_TIMEZONE_CHANGED Broadcast Receiver 时区改变的广播 ACTION_SCREE_ON Broadcast Receiver 屏幕被打开 Intent的Data属性实现拨号、发送短信、打开网页效果 效果预览 代码实现： MainActivity.java 1234567891011121314151617181920212223public class MainActivity extends AppCompatActivity { private Button btn; private EditText editText; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); btn = findViewById(R.id.main_btn); editText = findViewById(R.id.main_edit); btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Intent intent = new Intent(MainActivity.this,NewActivity.class); Bundle bundle = new Bundle(); bundle.putString(\"info\",editText.getText().toString()); intent.putExtras(bundle); startActivity(intent); } }); }} NewActivity.java 12345678910111213141516171819202122232425262728293031323334353637public class NewActivity extends Activity { private Button btn; private TextView tv; String info; protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.new_activity); btn = findViewById(R.id.new_button); tv = findViewById(R.id.textview1); //首先获取传递过来的信息 if(getIntent()!=null){ Intent i = getIntent(); Bundle bundle = i.getExtras(); info = bundle.getString(\"info\"); tv.setText(info); } //点击按钮时实现跳转到拨号页面 btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { takeCall(info); } }); } //跳转到拨号页面 private void takeCall(String info) { Intent intent = new Intent(); //实现隐式跳转 //uri.parse是将已经字符串类型转化为Uri的类型的办法 //Uri是一个唯一性标的标示字段 intent.setData(Uri.parse(\"tel://\"+info)); intent.setAction(Intent.ACTION_DIAL); startActivity(intent); }} 注： 若使用ACTION_CALL，则需定义权限 1&lt;uses-permission android:name=\"android.permission.CALL_PHONE\"/&gt; Activity的启动模式启动应用程序就会开启Activity栈，位于栈顶的Activity被用户可见，每启动一次Activity都会将该Activity的实例加入到Activity中，启动一个Activity的时候有四种模式，分别是：Standard（系统默认）、SingleTask、SingleTop、SingleInstance，每种启动模式操作的Activity都有所不同。 在AndroidManifest.xml定义： 1android:lunchMode=\"Standard/SingleTask/SingleTop/SingleInstance\" Standard标准的启动模式，该模式可以被设定，不在manifest设定时候，Activity的默认模式就是standard。在该模式下，启动的Activity会依照启动顺序被依次压入Task中： 问题：实现页面一跳转到页面二，再由页面二跳转到页面一。 SingleTop在该模式下，如果栈顶Activity为我们要新建的Activity（目标Activity），那么就不会重复创建新的Activity，而是复用位于栈顶的Activity对象，如果不位于栈顶，任就会重新创建Activity的实例对象。 SingleTask在启动Activity的时候，如果该Activity位于栈中，就会复用该Activity，这样的话，在该实例上的所有Activity都依次进行出栈，执行对应的onDestroy方法，直到当前需要启动的Activity位于栈顶。 问题：网页图集由第40个Activity跳转到第1个Activity、一键退出 SingleInstance启动Activity时，会复用已经存在的Activity实例，不管这个Activity的实例是位于哪一个应用当中，都会共享已经启动的Activity实例对象。使用了SingleInstance启动模式的Activity会单独开启一个共享栈，这个栈中只存在当前的Activity实例对象。","link":"/2019/02/15/Android%E5%BC%80%E5%8F%91-Activity2/"},{"title":"①Android开发-UI布局介绍","text":"常用的布局 | 布局定义方式 | Android UI屏幕适配 | 布局方式 Android中所有的UI（用户界面）都是使用View和ViewGroup对象建立的，View是一个可以将一些信息绘制在屏幕上并与用户产生交互的对象ViewGroup是一个可以包含多个的View和ViewGroup的容器，用来定义UI布局。 Android提供了一系列View和ViewGroup子类，开发者可以灵活的组合使用它们来完成界面布局、界面元素绘制和用户交互等工作 开发者还可以选择性地继承一些系统提供的View，来定义View，把自己定义的界面元素显示给用户。 Android的UI开发使用层次模型来完成，一般都是在一个ViewGroup中嵌套多层ViewGroup，每层中含有任意数目的View，但最好不要超过十层 1. 常用的布局 LinearLayout——线性布局 RelativeLayout——相对布局 FrameLayout——帧布局 TableLayout——表格布局 AbsoluteLayout——绝对布局 GridLayout——网格布局 2. 布局定义方式定义UI布局的最常用的方法是使用XML布局文件，如同HTML一样，XML为布局提供了一种可读的结构。XML中的每个元素都是，View或ViewGroup的子孙的对象组成的树。树根是一个ViewGroup对象，所有的叶节点都是View对象，树的分支节点都是ViewGroup对象。 Android中是ViewGroup可以嵌套包含很多View以及ViewGroup对象，ViewGroup是View的子类。 3. Android UI屏幕适配 屏幕尺寸：指屏幕的对角线长度，单位为英寸，1英寸== 2.45cm 屏幕分辨率：指水平和垂直方向的像素点个数，单位px，1px== 1像素点，一般以垂直像素*水平像素，例如 1920 * 1080 屏幕像素密度：指每英寸上的像素点数，单位是dpi，dpi:dot per inch。屏幕像素密度与屏幕尺寸有关。 px：像素点，构成图像的最小单位 dip：device independent pixels（设备独立像素），也是密度无关像素。以160dpi为基准，1dip=1px。 dp：与dip相同。 sp：专门用于字体的像素单位，一般定义为偶数。 4. LinearLayout （线性布局）1. vertical / horizontal 使用android:orientation= &quot;vertical/horizontal&quot;定义排列方向 1234567891011121314//linearlayout.xml&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" &gt; &lt;!--线性布局是按照水平和垂直排布的，默认是水平排布的 orientation：用来指定当前线性布局排布的方向 horizontal:水平 vertical:垂直--&gt;&lt;/LinearLayout&gt; 2. margin / padding 属性 含义 android:layout_marginXXX(XXX:left/tpo) 设置该控件距离左、上边界的距离 android:paddingXXX(XXX:left/top) 设置控件内部距离控件边缘的距离 区分：margin:表示控件距离其他或者屏幕边缘的间距。—外边距padding:表示控件的内部内容距离控件边缘的间距。—内边距 12345678910&lt;Button android:id=\"@+id/button1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:padding=\"30dp\" android:text=\"Button\" /&gt; &lt;!--wrap_content :代表包裹内容，适合内容大小 match_parent :父类大小 layout_margn是指组件距离父窗体的距离， padding是指组件中的内容距离组件边缘的距离--&gt; 3. gravity / layout_gravity 属性 含义 android:gravity 用于设置该View内部内容的对齐方式 android:layout_gravity 用于设置该View在其父类中的对齐方式 注意：如果线性布局的排布方式为水平，那么layout_gravity在水平方向上就不起作用，只有在垂直方向上起作用，反之亦然。 可选值包括：left、right、top、bottom、center、horizoncenter_vertical、center_horizontalbottom\\center_horizontal（使用\\组合使用） 4. layout_weight （LinearLayout特有属性） LinearLayout特有属性，android:layout_weight,表示比重，可实现百分比布局，如果控件为 match_parent,则layout_weight的值与占比重反相关，即：其值越大，占用比例越小，如果控件为 wrap_content，则对比重判断则为正相关，即其值越小，占用的比例越小。 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:weightSum=\"3\"&gt; &lt;!--总的权重--&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"#00ff00\" android:layout_weight=\"2\"&gt; &lt;!--绿色区，权重为2--&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"#ff0000\" android:layout_weight=\"1\"&gt; &lt;!--红色区，权重为1--&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 注意：若在一个页面中，有一个有权重控件，和一个无权重的控件，系统会先给无权重的控件分配空间后，才会得到需要百分比的空间大小，进行百分比划分。权重布局只存在于LinearLayout中，其余布局无效。 5. RelativeLayout（相对布局)RelativeLayout（相对布局)：按照控件相互之间的相对位置来确定，RelativeLayout中往往需要定义每一个控件的资源ID。 1. 常用属性 常用属性 含义 layout_alineParentXXX（XXX:方向） 对齐方式 android:layout_marginXXX 外部间距 android:paddingXXX(XXX:left/top) 内部间距 android:layout_centerVertical 垂直居中 android:layout_centerHorizontal 水平居中 android:layout_centerInParent 父类的中部 注意：layout_width和layout_height是在平面图形中不可或缺的两个属性，任何图形需要显示都需要宽和高。 2. android:layout_toRightOf（在某个控件的右方）12345678910111213141516&lt;Button android:id=\"@+id/button1\" android:layout_weight=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"30dp\" android:layout_marginLeft=\"30dp\" android:padding=\"20dp\" android:text=\"Button\"/&gt; &lt;!--@+id:表示系统本来不存在的对应ID值，其方向性的单词可以更换。 以上Button可作为参照物--&gt;&lt;Button android:layout_weight=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_toRightOf=\"@id+button1\" android:layout_alingnBottom=\"@+id/button1\"/&gt; &lt;!--在控件的右方、底部--&gt; 3. anignBaseline （基准线对齐）4. layout_below （在XX的下方） 注意： 针对相对布局而言，一般不会过多给定很多想关联的属性，否则耦合性就会大大增加。相对布局的重点在于理解控件id，在相对布局中的控件一般都存在id属性，+id表示是系统中本来不存在的对应的id值，需要将这个id值添加到系统中，@id表示从系统中去除已经添加好的id。 6. TableLayout （表格布局）TableLayout属于行和列形式的管理控件，每行为一个TableRow对象也可以是一个View对象。在TableRow中还可以继续添加其他控件，每添加一个子控件就成一列，TableLayout不会生成边框。 TableLayout是继承至LinearLayout，即TableLayout有LinearLayout的属性（见上文）。同时也有自己的特有属性： XML属性名 说明 android:collapseColumns 设置指定的列为collapse，该列会被隐藏 android:shrinkColumns 设置指定的列为shrinkable，该列的宽度进行收缩，自适应父类容器的大小 android:stretchColumns 设置指定的列为stretch,该列会被拉伸，填充满表格的空白区域 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;TableLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:stretchColumns=\"0,1,2\" android:shrinkColumns=\"0\" android:collapseColumns=\"2\"&gt; &lt;!--stretch拉伸1,2,3列， shrinkable收缩第一列， collapse隐藏第一列 拉伸后收缩时因为，如果第一列内容过多，会覆盖第二三列， 因此要收缩第一列，以显示所有内容--&gt; &lt;TableRow android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;!--此处Table可不设定宽高值，系统自动给定--&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:padding=\"5dp\" android:text=\"姓名\"/&gt; &lt;!--TableLayout是LinearLayout的子类，可设置gravity、padding等属性--&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"性别\"/&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"电话\"/&gt; &lt;/TableRow&gt; &lt;TableRow android:layout_width=\"match_patent\" android:layout_height=\"wrap_content\" android:\"right\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginRight=\"30dp\" android:text=\"总计：100\"/&gt; &lt;/TableRow&gt; &lt;!--此TableRow未遵循此表格布局--&gt;&lt;/TableLayout&gt; 7. FrameLayout （帧布局）/ AbsoluteLayout （绝对布局）FrameLayout（帧布局）默认是按左上角(0,0)开始排布，在帧布局下的每一个控件都是以画面的形式进行呈现，最开始定义的控件出现在最下方，最后定义的控件出现在最上方，一般用于手机联系人的导航显示字母、帧动画等内容。 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"#00ff00\" android:text=\"你好\"/&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_margin=\"30dp\" android:background=\"#ff0000\" android:text=\"页面\"/&gt;&lt;/FrameLayout&gt; AbsoluteLayout（绝对布局），又叫做坐标布局，可以直接指定子元素的绝对位置，这种布局简单、直观性强。由于手机屏幕尺寸差别较大，使用绝对定位适应性会比较差，不推荐使用。一般用于固定屏幕手机。 属性 含义 android:layout_x 确定X坐标，以左上角为顶点 android:layout_y 确定Y坐标，以左上角为顶点 注意：若不设置layout_x和layout_y，那么他们的默认值是(0,0)他们会出现在左上角。 8. GridLayout （网格布局）GridLayout（网格布局）是在android4.0版本以上出现的布局，可以实现并行和并列的效果。 常用属性 含义 android:layout_columnSpan 扩展列的数目 android:layout_rowSpan 扩展行的数目 android:layout_gravity 填充方式 columnCount 定义存在多少列 rowCount 定义存在多少行 注意： GridLayout与TableLayout有什么不同？ TableLayout定义TableRow来呈现内容，GridLayout可以直接定义控件来使用，并且TableLayout不可以合并行或列。 计算器页面的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;GridLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:columnCount=\"4\"&gt;&lt;!--使用columnCount定义一共4列--&gt; &lt;!--放置按键--&gt; &lt;Button android:id=\"@+id/num1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"1\"/&gt; &lt;Button android:id=\"@+id/num2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"2\"/&gt; &lt;Button android:id=\"@+id/num3\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"3\"/&gt; &lt;Button android:id=\"@+id/chu\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"/\"/&gt; &lt;Button android:id=\"@+id/num4\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"4\"/&gt; &lt;Button android:id=\"@+id/num5\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"5\"/&gt; &lt;Button android:id=\"@+id/num6\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"6\"/&gt; &lt;Button android:id=\"@+id/cheng\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"*\"/&gt; &lt;Button android:id=\"@+id/num7\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"7\"/&gt; &lt;Button android:id=\"@+id/num8\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"8\"/&gt; &lt;Button android:id=\"@+id/num9\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"9\"/&gt; &lt;Button android:id=\"@+id/jian\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"-\"/&gt; &lt;Button android:id=\"@+id/num0\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_columnSpan=\"2\" android:layout_gravity=\"fill\" android:text=\"0\"/&gt; &lt;!--columnSpan合并两列gravity填充整个区域--&gt; &lt;Button android:id=\"@+id/dian\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\".\"/&gt; &lt;Button android:id=\"@+id/jia\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_rowSpan=\"2\" android:layout_gravity=\"fill\" android:text=\"+\"/&gt; &lt;Button android:id=\"@+id/deng\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_columnSpan=\"3\" android:layout_gravity=\"fill\" android:text=\"=\"/&gt;&lt;/GridLayout&gt; Android UI开发分类 界面布局开发——定义界面的布局 控件开发——定义单个界面元素 AdapterView与Adapter开发——列表显示（适配器的开发） UI组件开发——对话框、通知、菜单等 自定义View、图形图像和动画——通过代码，自行绘制界面。","link":"/2019/01/25/Android%E5%BC%80%E5%8F%91-UI%E5%B8%83%E5%B1%80%E4%BB%8B%E7%BB%8D/"},{"title":"②Android开发-常用控件（一）","text":"TextView | Button | CheckBox/RadioButton 1. TextView概念：用来显示文本的控件，被称之为文本域。 常用属性： text：显示的内容 textSize：文字的大小 textColor：文字的颜色 visibility：是否显示 visible：默认可见，invisible：表示不可见，但是控件显示区域做了保留，gone：可以隐藏控件并且当前控件区域不做保留。 maxLength：最大长度 maxLines：最大行数 autoLink：自动连接的类型 1234567&lt;TextView android:layout_width=\"wrap_content\" android:layout_length=\"wrap_content\" android:textColor=\"#0000ff\" android:textSize=\"20sp\" android:autoLink=\"web\" android:text=\"https://www.baidu.com\"/&gt; 跑马灯效果： singleLine：单行显示 ellipsize：当文字过长时，文字省略位置，属性值：none、start、middle、end、marquee（跑马灯） focusable：是否支持获取焦点 focusableInTouchMode：是否支持触摸获取焦点 scrollHorizontally：是否水平滑动 1234567891011&lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"20dp\" android:textSize=\"20sp\" android:singleLine=\"true\" android:ellipsize=\"marquee\" android:focusable=\"true\" android:focusableInTouchMode=\"true\" android:scrollHorizontally=\"true\" android:text=\"床前明月光，疑是地上霜。举头望明月，低头思故乡。\"/&gt; TextView显示图片： drawableTop/letf/right/bottom：显示图片位于文字上、下、左、右。 123456&lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"APP\" android:drawableTop=\"@drawable/ic_launcher\" android:gravity=\"center\"/&gt; 2. Button按钮的四种监听给Button按钮设置点击的监听方式： 使用匿名监听类，直接将需要设置的onClickListener接口对象初始化。内部的OnClick方法会在被点击的时候执行 先在XML文件中新建Buton按钮，并设置按钮id： 12345&lt;Button android:id=\"@+id/btn\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"点击\"/&gt; 随后在gen目录下的R文件中就会出现这个Button按钮 id 123456...public static final class id { public static final int action_settings=0x7f080001; public static final int btn=0x7f080000;}... 如果需要给Butttom按钮添加监听，需要在java代码中找到这个按钮，在*MainActivity.java文件中： 1234567891011121314151617181920212223242526import android.app.Activity;import android.os.Bundle;import android.util.Log;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.Button; //导入Button包public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //通过id找到关联布局中的View控件 Button btn = (Button)findViewById(R.id.btn); //给button按钮添加点击监听 btn.setOnClickListener(new View.OnClickListener() { //只要当前设置的监听器被触发，这个方法就被执行。 @Override public void onClick(View v) { Log.i(\"Tag\", \"点击了Buttona按钮\"); } }); }} 在XML文件中定义onClick属性，java代码中对应方法 在XML文件中新建Buton按钮，并定义onClick属性： 123456&lt;Button android:id=\"@+id/btn\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"skip\" android:text=\"点击\"/&gt; 在*MainActivity.java文件中定义skip方法，注意需设为public void 12345678910public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } public void skip(View v) { Log.i(\"TAG\", \"点击了Button\"); }} 注：在XML文件中定义onClick属性，属性中对应的值需要在java代码中编写对应的方法名，参数View必须定义，方法类似于：public void 方法名(View v)。 Activity实现onClickListener接口 在MainActivity方法中继承OnClickListener，并实现onClick方法。 注：在给Button按钮设置点击监听的时候，直接让当前的Activity实现onClickListener接口，这样传入监听的对象就可以使用this(Activity.this) 1234567891011121314151617public class MainActivity extends Activity implements OnClickListener{ @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //控件初始化，找到控件的id Button btn = (Button) findViewById(R.id.btn); //给Button按钮设置点击监听 btn.setOnClickListener(this); } @Override public void onClick(View v) { //点击实现的方法 Log.i(\"TAG\", \"点击了当前的Button按钮\"); }} 其他类实现onClickListener接口 让另外一个类来实现onClickListener接口，这样如果控件在需要设置点击监听的时候，直接传入该类的对象即可。 12345678910111213141516171819public class MainActivity extends Activity{ @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //控件初始化，找到控件的id Button btn = (Button) findViewById(R.id.btn); //给Button按钮设置点击监听 btn.setOnClickListener(new Mylistener()); } //定义一个类来实现onClickListener接口 class MyListener implements OnClickListener{ @Override public void onClick(View v) { Log.i(\"TAG\", \"点击了当前的Button按钮\"); } }} 注意： 实现Button按钮监听的核心就是方法onClick，其参数v：就是发生点击的View控件，即上述代码中的Button按钮，如果XML定义了多个Button按钮，可通过gitID方法获取Button按钮id，然后通过switch语句遍历id值。 1234567891011121314151617181920212223242526272829303132public class MainActivity extends Activity{ @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //控件初始化，找到控件的id Button btn = (Button) findViewById(R.id.btn); Button btn2 = (Button) findViewById(R.id.btn2); //给Button按钮设置点击监听 MyListener listener = new MyListener(); btn.setOnClickListener(linster); btn2.setOnClickListener(linster); } //定义一个类来实现onClickListener接口 class MyListener implements OnClickListener{ @Override public void onClick(View v) { switch (v.getId()) { case R.id.btn: //点击了Bottom Log.i(\"TAG\", \"点击了当前的Button按钮\"); break; case R.id.btn2: //点击了Bottom2 Log.i(\"TAG\", \"点击了当前的Button2按钮\"); break; default: break; } } }} 3. CheckBox / RadioButton3.1 CheckBoxCheckBox是用来进行多选的按钮，CheckBox是选择框，只有选中和未选中两种状态，一般使用在多个选项都可以选择的情况下。 OnCheckedChangeListener是定义在CompoundButton下的监听对象，因为CheckBox是ConpoundButton的子类，所以可以直接使用。 实例——选择个人爱好： 在XML文件中定义按钮 1234567891011121314151617181920212223242526272829303132333435&lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textSize=\"20sp\" android:text=\"请选择您的爱好\"/&gt;&lt;CheckBox android:id=\"@+id/palyball\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"踢球\"/&gt;&lt;CheckBox android:id=\"@+id/swim\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"游泳\"/&gt;&lt;CheckBox android:id=\"@+id/sleep\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"睡觉\"/&gt;&lt;CheckBox android:id=\"@+id/run\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"跑步\"/&gt;&lt;CheckBox android:id=\"@+id/dance\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"跳舞\"/&gt; &lt;Button android:id=\"@+id/check\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"查看选中\"/&gt; 实现Button按钮控件监听，CheckBox选择结果显示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class MainActivity extends Activity{ private Button cheak; private CheckBox swim,playball,run,dance,sleep; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //控件初始化 cheak = (Button) findViewById(R.id.check); swim = (CheckBox) findViewById(R.id.swim); playball = (CheckBox) findViewById(R.id.palyball); run = (CheckBox) findViewById(R.id.run); dance = (CheckBox) findViewById(R.id.dance); sleep = (CheckBox) findViewById(R.id.sleep); //使用匿名内部类形式进行Button点击监听 cheak.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { showCheck(); } }); } public void showCheck(){ //可变字符串表示 StringBuffer sbf = new StringBuffer(); //选中操作 if(swim.isChecked()){ sbf.append(swim.getText().toString()+\",\"); } if(playball.isChecked()){ sbf.append(playball.getText().toString()+\",\"); } if(run.isChecked()){ sbf.append(run.getText().toString()+\",\"); } if(dance.isChecked()){ sbf.append(dance.getText().toString()+\",\"); } if(sleep.isChecked()){ sbf.append(sleep.getText().toString()+\",\"); } //判断当前的字符是否可以进行截取 if (sbf.length()&gt;0) { String str = sbf.substring(0,sbf.length()-1); Log.i(\"TAG\", \"选中的内容有\"+str); Toast.makeText(this, \"选中的内容有：\"+str,Toast.LENGTH_SHORT).show(); }else{ Log.i(\"TAG\", \"请选择您的爱好\"); Toast.makeText(this, \"请选择您的爱好\", Toast.LENGTH_SHORT).show(); } }} Toast：提示机制，提示用户一些简单的信息不能与用户进行交互，显示的时长是有限的。 使用案例： Toast.makeText(this, &quot;选中的内容有：&quot;+str,Toast.LENGTH_SHORT).show(); 步骤： 调用静态方法makeText； 在makeText方法中定义需要呈现的上下文，需要显示的内容及需要显示的时长； 调用show方法进行显示（makeText返回值任为Toast对象）； 注：因为Toast.class文件定义中Toast.LENGTH_SHORT=0 ，Toast.LENGTH_LONG=1故可直接写0或1。 3.2 RadioButtonRadioButton是单选按钮，如果让几个单选按钮之间产生互斥关系，需要使用一个RadioGroup来组织多个或一个RadioButton，在同一个RadioGroup中，一次只能选中一个RadioButton。 CompoundButton是RadioButton的父类，也是CheckBox的父类，OnCheckedChangeListener是定义在CompoundButton的监听，所以CheckBox和RadioButton都可以使用 实例——选择性别： 定义控件 1234567891011121314151617181920&lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textSize=\"20sp\" android:text=\"请选择您的性别\"/&gt;&lt;RadioGroup android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"&gt; &lt;RadioButton android:id=\"@+id/male\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"男\"/&gt; &lt;RadioButton android:id=\"@+id/famale\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"女\"/&gt;&lt;/RadioGroup&gt; 实现按钮监听及按钮间的互斥关系 1234567891011121314151617181920212223242526272829303132333435363738394041import android.app.Activity;import android.os.Bundle;import android.widget.CompoundButton;import android.widget.RadioButton;import android.widget.Toast;public class RadioActivity extends Activity { private RadioButton male,famale; protected void onCreate(Bundle savedInstanceState){ super.onCreate(savedInstanceState); setContentView(R.layout.radio1); //初始化控件 male = (RadioButton) findViewById(R.id.male); famale = (RadioButton) findViewById(R.id.famale); //给Button按钮添加选中的监听 male.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){ @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) { if(isChecked){ Toast.makeText(RadioActivity.this, \"选中的是\"+male.getText(), Toast.LENGTH_SHORT).show(); } } }); famale.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){ @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) { if(isChecked){ Toast.makeText(RadioActivity.this, \"选中的是\"+famale.getText(), Toast.LENGTH_SHORT).show(); } } }); }} 若有多个按钮，可以给存放单选按钮的RadioGroup设置监听，方法都叫做OnCheckedChangeListener，但所属的类是不同的。 给RadioGroup设置id后，java代码： 1234567891011121314151617181920212223242526272829303132333435public class RadioActivity extends Activity { //声明变量 private RadioButton male,famale; private RadioGroup group; protected void onCreate(Bundle savedInstanceState){ super.onCreate(savedInstanceState); setContentView(R.layout.radio1); //初始化控件 male = (RadioButton) findViewById(R.id.male); famale = (RadioButton) findViewById(R.id.famale); group =(RadioGroup)findViewById(R.id.radiogroup); //给Button按钮添加选中的监听,如果当这个RadioGroup中的单选按钮发生变化时，就会执行OnCheckedChangeListener group.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() { public void onCheckedChanged(RadioGroup group, int checkedId) { //遍历 switch (checkedId) { case R.id.male: Toast.makeText(RadioActivity.this, \"选中的是：\"+male.getText(), Toast.LENGTH_SHORT).show(); break; case R.id.famale: Toast.makeText(RadioActivity.this, \"选中的是：\"+famale.getText(), Toast.LENGTH_SHORT).show(); break; default: break; } } }); }} Android UI开发分类 界面布局开发——定义界面的布局 控件开发——定义单个界面元素 AdapterView与Adapter开发——列表显示（适配器的开发） UI组件开发——对话框、通知、菜单等 自定义View、图形图像和动画——通过代码，自行绘制界面。","link":"/2019/01/26/Android%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B61/"},{"title":"③Android开发-常用控件（二）","text":"EditText | ImageView | 综合实例：登录界面 4. EditText概念：用来输入文本的控件，被称为文本输入框，TextView是EditText的父类,因而可以使用其所有属性。 常用属性： text：显示的内容 textSize：文字的大小 textColor：文字的颜色 visibility：是否显示 maxLength：显示的最大长度 maxLines：显示的最大行数 hint：输入提示，有输入后不再显示提示内容 inputType：限制输入类型，如number、textPassword(密文输入) ems：默认EditText的输入框宽度，若EditText宽度为match_parent，则ems属性失效 实例1：EditText实现明密文切换EditText呈现文字显示的时候如果需要进行明密文切换，需要给EditText设置对应的TransformationMethod，给定需要转化的类型就可以实现明密文切换。注意切换完成之后的光标位置，以免出现输入密码错误。 放置控件： 123456789101112131415&lt;EditText android:id=\"@+id/input\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:singleLine=\"true\" android:hint=\"请输入密码\" android:inputType=\"textPassword\"/&gt;&lt;CheckBox android:id=\"@+id/box\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentRight=\"true\" android:layout_below=\"@+id/input\" android:text=\"查看密码\" /&gt; Java代码实现： 123456789101112131415161718192021222324252627282930public class MainActivity extends Activity { private EditText input; private CheckBox box; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化 input = (EditText) findViewById(R.id.input); input.setCursorVisible(false); //设置输入光标隐藏 box = (CheckBox) findViewById(R.id.box); box.setOnCheckedChangeListener(new OnCheckedChangeListener() { @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) { if (isChecked) { //选中，显示明文 input.setTransformationMethod(HideReturnsTransformationMethod.getInstance()); } else { //未选中，显示密文 input.setTransformationMethod(PasswordTransformationMethod.getInstance()); } //将光标移动到密码末尾 input.setSelection(input.getText().length()); } }); }} 实例2：EditText添加内容发生变化的监听如果在文本进行输入的过程中，需要针对文本的输入进行监听，就需要用到TextWatcher进行监听。该建监听会回调该类下的三个方法：onTextChanged beforeTextChanged afterTextChanged 参数说明： onTextChanged：文本发生变化的时候执行的方法 s：表示改变之前的的内容，通常start和count组合，可以在s中读取本次改变字段中被改变的内容，而after表示改变之后的内容的数量 start：开始的位置 before：改变之前的数量 count：表示新增加的数量 beforeTextChanged：文本发生变化之前执行的方法 s：表示改变之前的的内 start：开始的位置 count：被改变的原有内容的个数 after：改变之后的内容数量 afterTextChanged：文本发生变化之后执行的方法 s：表示最终的内容 测试代码： 1234567891011121314151617181920212223input = (EditText) findViewById(R.id.myinput);// 针对EditText的输入进行监听input.addTextChangedListener(new TextWatcher() { @Override public void onTextChanged(CharSequence s, int start, int before, int count) { // 文本发生变化的时候执行的方法 Log.i(\"TAG\", \"onTextChange方法被调用,s:\"+s+\"-start:\"+start+\"-before:\"+before+\"-count:\"+count); } @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) { // 文本发生变化之后执行的方法 Log.i(\"TAG\", \"beforeTextChanged方法被调用,s:\"+s+\"-start:\"+start+\"-count:\"+count); } @Override public void afterTextChanged(Editable s) { // 文本发生变化之后执行的方法 Log.i(\"TAG\", \"afterTextChanged方法被调用,s:\"+s); } });} 完整代码： 1234567&lt;EditText android:id=\"@+id/myinput\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:singleLine=\"true\" android:layout_marginTop=\"50dp\" android:hint=\"请输入\"/&gt; 123456789101112131415161718192021222324252627282930public class MainActivity extends Activity { private EditText input; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 初始化 input = (EditText) findViewById(R.id.myinput); // 针对EditText的输入进行监听 input.addTextChangedListener(new TextWatcher() { @Override public void onTextChanged(CharSequence s, int start, int before, int count) { } @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) { } @Override public void afterTextChanged(Editable s) { // 文本发生变化之后执行的方法 if (s.length()==11) { Toast.makeText(MainActivity.this, \"输入格式正确\", Toast.LENGTH_SHORT).show(); } } }); }} 5. ImageView概念：用来显示图片的控件 基本属性： src：指定当前ImageView中填充的内容，如果是PNG格式等有透明属性的图片的话，就会在透明的地方显示出background的背景，而不是黑色或者其他系统默认的填充色等。 background：指定当前控件的背景，src浮在background上方。 如果需要在代码中动态设定当前ImageView的填充内容，可以使用setImageResource进行指定。ImageView也可以通过setOnClickListener设置监听。 123456789//ImageView监听image = (ImageView) findViewById(R.id.image);image.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Toast.makeText(MainActivity.this, \"点击了Image\", Toast.LENGTH_SHORT).show(); } }); scaleType：用来处理图片放在ImageView上显示的样子、如何进行缩放以及是显示图片的整体还是部分等。 使用方法： 在布局文件中，设置ImageView的属性scaleType=“XXX” 在java文件中使用imageview.setScaleType=“XXX” ScaleType 的常用取值 matrix 用矩阵来绘制（从左上角开始的矩阵区域） fitXY 把图片不按照比例的扩大、缩小到View的宽度，显示在view的上部分位置，确保图片完整呈现并充满view。 fitStart 把图片按照比例扩大、缩小到view的宽度，显示到view的上部分位置，确保图片完整呈现。 fitCenter 把图片按照比例扩大、缩小到view的宽度，显示到view的居中位置，确保图片完整呈现。 fitEnd 把图片按照比例扩大、缩小到view的宽度，显示到view的下部分位置，确保图片完整呈现。 center 按图片原来的大小居中显示，若宽度超过View截取居中部分显示；当小于View范围，居中显示。 centerCrop 按比例扩大、缩小图片居中显示并充满View。 centerInside 将图片的内容完整的居中显示，若宽度超过View按比例缩小显示；当小于View范围，居中显示 （控件）ImageButton：用来相应图片的点击事件。 区别：一般用ImageButton来相应点击效果，用ImageView来呈现一个图片控件。ImageButton是ImageView的子类。 实例3：图片切换选择器在Java代码中如果需要对Image设置不同的显示，通过api—setImageResource 完整代码： 123456789101112131415161718192021222324&lt;ImageView android:id=\"@+id/image\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"1\" android:src=\"@drawable/im\"/&gt;&lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;Button android:id=\"@+id/pre\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/pre\"/&gt; &lt;View android:layout_width=\"0dp\" android:layout_height=\"1px\" android:layout_weight=\"1\"/&gt; &lt;Button android:id=\"@+id/next\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/next\"/&gt;&lt;/LinearLayout&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MainActivity extends Activity implements OnClickListener{ private ImageView image; private Button pre,next; //图片在R文件中呈现的id值组成的int类型的数值 private int[] images= {R.drawable.a,R.drawable.b,R.drawable.c,R.drawable.d,R.drawable.e,R.drawable.f}; //表示选中图片的索引位置 private int position = 0; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化 image = (ImageView) findViewById(R.id.image); pre = (Button) findViewById(R.id.pre); next = (Button) findViewById(R.id.next); //设置按钮的点击监听 pre.setOnClickListener(this); next.setOnClickListener(this); } @Override public void onClick(View v) { switch (v.getId()) { case R.id.pre: //点击了上一张 position--; if (position&lt;0) { position = images.length-1; } image.setImageResource(images[position]); break; case R.id.next: //点击了下一张 position++; if(position&gt;=images.length){ position = 0; } image.setImageResource(images[position]); break; default: break; } }} 综合实例：登陆页面 实现效果： 布局代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" android:background=\"@drawable/background\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" tools:context=\"com.str.register.MainActivity\" &gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"85dp\" android:gravity=\"center\" android:textSize=\"25sp\" android:padding=\"5dp\" android:text=\"@string/register\"/&gt; &lt;RelativeLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"35dp\" android:layout_marginRight=\"35dp\"&gt; &lt;TextView android:id=\"@+id/user\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignBaseline=\"@+id/username\" android:textSize=\"18sp\" android:text=\"@string/username\"/&gt; &lt;EditText android:id=\"@+id/username\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"20dp\" android:layout_toRightOf=\"@+id/user\" android:hint=\"@string/usernamehint\"/&gt; &lt;TextView android:id=\"@+id/pass\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignBaseline=\"@+id/password\" android:textSize=\"18sp\" android:layout_below=\"@+id/username\" android:text=\"@string/password\"/&gt; &lt;EditText android:id=\"@id/password\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"20dp\" android:hint=\"@string/passwordhint\" android:layout_toRightOf=\"@+id/pass\" android:layout_below=\"@+id/username\" android:layout_alignLeft=\"@+id/username\" android:inputType=\"textPassword\"/&gt; &lt;/RelativeLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"20dp\" android:layout_marginLeft=\"35dp\" android:layout_marginRight=\"35dp\" android:gravity=\"center_vertical\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textSize=\"18sp\" android:text=\"@string/sex\"/&gt; &lt;RadioGroup android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\"&gt; &lt;RadioButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:textSize=\"18sp\" android:text=\"@string/male\"/&gt; &lt;RadioButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:textSize=\"18sp\" android:text=\"@string/famale\"/&gt; &lt;/RadioGroup&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"20dp\" android:layout_marginLeft=\"35dp\" android:layout_marginRight=\"35dp\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textSize=\"18sp\" android:text=\"@string/hobby\"/&gt; &lt;CheckBox android:id=\"@+id/dance\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:text=\"@string/dance\"/&gt; &lt;CheckBox android:id=\"@+id/sing\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:text=\"@string/sing\"/&gt; &lt;/LinearLayout&gt; &lt;Button android:layout_width=\"match_parent\" android:layout_height=\"35dp\" android:background=\"#50bbf3\" android:layout_marginTop=\"20dp\" android:layout_marginLeft=\"35dp\" android:layout_marginRight=\"35dp\" android:textSize=\"15sp\" android:text=\"@string/registerbuton\"/&gt;&lt;/LinearLayout&gt; Android UI开发分类 界面布局开发——定义界面的布局 控件开发——定义单个界面元素 AdapterView与Adapter开发——列表显示（适配器的开发） UI组件开发——对话框、通知、菜单等 自定义View、图形图像和动画——通过代码，自行绘制界面。","link":"/2019/01/27/Android%E5%BC%80%E5%8F%91-%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B62/"},{"title":"④Android开发-适配器（一）","text":"ArrayAdapter | SimpleAdapter | 自定义适配器 | ListView AdapterView即Adapter（适配器）控件，其内容通常是一个包含多项相同格式资源的列表，每次只显示其中的一项，这个存放Adapter控件内容的列表，在Android被称为AdapterView（适配器View）。 使用的时候一般都会先给适配器填充内容，然后将已经设定好内容的适配器设置到AdapterView上进行显示。 Adapter适配器常用的有： ArrayAdapter、SimpleAdapter以及自定义Adapter *常用适配器View： * ListView（列表）、Spinner（下拉列表）、GirdView（网格图） 继承关系：如图 1. ArrayAdapterArrayAdapter是最简单的适配器，一般使用在表项列表中只含有文本信息的情况，数据源包含字符串数组，字符串List集合，以及string-array，使用的item布局需要是TextView。 适配的过程需要存在数据源、适配器，将数据源放在适配器上，再将适配器设置到AdapterView上 Adapter构造方法一： context：使用到的上下文对象 resource：使用的布局文件 object：数据源对象 new ArrayAdapter(context, resource)new ArrayAdapter(context, resource, objects)new ArrayAdapter(context, resource, textViewResourceId, objects) 全部详解 12345&lt;ListView android:id=\"@+id/lv\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt;&lt;/ListView&gt; 123456789101112131415161718192021private ListView lv; //适配器Viewprivate ArrayAdapter&lt;String&gt; adapter; //适配器private List&lt;String&gt; lt; //数据源@Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //适配器View初始化 lv = (ListView) findViewById(R.id.lv); //数据源初始化 lt = new ArrayList&lt;String&gt;(); for(int i=0;i&lt;10;i++){ lt.add(\"数据\"+i); } //适配器初始化 adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_expandable_list_item_1,lt); //将适配器设置到ListView上 lv.setAdapter(adapter);} Java知识点：数组、List、ArrayLis、T的用法及区别 Adapter构造方法二： ArrayAdapter.createFromResource(context, textArrayResId, textViewResId) 12//使用这种方式构造的适配器泛型是字符序列private ArrayAdapter&lt;CharSequence&gt; adapter; 1adapter = ArrayAdapter.createFromResource(this, R.array.list_array, android.R.layout.simple_expandable_list_item_1); 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!-在res/values文件夹下新建资源文件list_array-&gt;&lt;resources&gt; &lt;string-array name=\"list_array\"&gt; &lt;item&gt;数据元素1&lt;/item&gt; &lt;item&gt;数据元素2&lt;/item&gt; &lt;item&gt;数据元素3&lt;/item&gt; &lt;item&gt;数据元素4&lt;/item&gt; &lt;item&gt;数据元素5&lt;/item&gt; &lt;item&gt;数据元素6&lt;/item&gt; &lt;item&gt;数据元素7&lt;/item&gt; &lt;item&gt;数据元素8&lt;/item&gt; &lt;item&gt;数据元素9&lt;/item&gt; &lt;item&gt;数据元素10&lt;/item&gt; &lt;/string-array&gt;&lt;/resources&gt; 注意：在使用ArrayAdapter的时候，需确保当前显示的item的布局根节点是TextView（在自定义布局时） ListView采用MVC模式将前端显示和后端数据分离，不能使用ListView.add或类似方法添加数据，需要通过实现了ListAdapter接口的Adapter对象加载数据。 MVC(model view controller)设计模式： M—数据模型—数据模型 V—显示的视图控件—AdapterView C—控制器—adapter 特点：显示和后端数据相分离，互不干涉。 为ListView提供数据的List或数组相当于MVC模式中的M（数据模型Model），ListView相当于MVC模式中的V（视图View），Adapter对象相当于MVC模式中的C（控制器）。 一般来说ListView是常用的AdapterView，使用在滑动列表显示中，通常使用于： item的点击事件 setOnItemClickListener(listener) item的长按事件： setOnItemLongClickListener(listener) 可以根据item的点击实现不同的效果。 效果预览 点击事件12345678910111213//给ListView的item设置的点击事件 lv.setOnItemClickListener(new OnItemClickListener() { //parent:适配器设置到的adapterView对象，在这里表示的是ListView //view:适配器item对应的View //position:适配器索引位置,从0开始依次向下递增 //id:在listView中的item对应的行id @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) { Toast.makeText(MainActivity.this,\"点击的是索引\"+position+\",id:\"+id, Toast.LENGTH_SHORT).show(); } }); 长按事件123456789101112131415//给ListView的item设置的长按删除操作lv.setOnItemLongClickListener(new OnItemLongClickListener() {@Overridepublic boolean onItemLongClick(AdapterView&lt;?&gt; parent, View view, int position, long id) { //删除对应的item索引 lt.remove(position); //如果适配器发生变化，需要当前的listView也通知到 adapter = new ArrayAdapter&lt;String&gt;(MainActivity.this, android.R.layout.simple_expandable_list_item_1, lt); lv.setAdapter(adapter); return false; }}); 注意：若将onItemLongClick返回值改为true，点击事件就不会被响应 上述方法每删除依次就需要对适配器进行重建，形成资源浪费，可以调用adapter.notifyDataSetChanged()进行优化。 1234567891011lv.setOnItemLongClickListener(new OnItemLongClickListener() { @Override public boolean onItemLongClick(AdapterView&lt;?&gt; parent, View view, int position, long id) { //删除对应的item索引 lt.remove(position); adapter.notifyDataSetChanged(); return false; }}); 2. SimpleAdapterSimpleAdapter可以使用在多控件进行适配的效果中，SimpleAdapter构造方法： new SimpleAdapter(context, data, resource, from, to); 参数解释： context:上下文对象 data:数据源 List&lt;Map&lt;String,Object&gt;&gt; resource:item对应的布局文件 from:表示由map中定义的key组成的字符串类型的数组 to:需要显示的控件id组成的int类型的数组 并且要保证from与to一一对应 与ArrayAdapter对比： 比ArrayAdapter支持item显示的控件更多 数据源的格式略微复杂，ArrayAdapter适用在只是TextView呈现字符串上，simpleAdapter可以适配多控件 数据源：ArrayAdapter的数据源为List，SimpleAdapter的数据源List&lt;Map&lt;String,Object&gt;&gt; 效果预览： 代码实现： 1234567891011121314151617181920212223242526272829303132333435public class MainActivity extends Activity { private ListView lv; private SimpleAdapter sAdapter; private List&lt;Map&lt;String, Object&gt;&gt; list; private Map&lt;String, Object&gt; map; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //View初始化 lv = (ListView) findViewById(R.id.lv); //数据源初始化 list = new ArrayList&lt;Map&lt;String,Object&gt;&gt;(); for(int i = 0;i&lt;40;i++){ map = new HashMap&lt;String, Object&gt;(); map.put(\"data\", \"数据\"+i); map.put(\"intro\", \"介绍\"+i); list.add(map); } String[] from={\"data\",\"intro\"}; int[] to = {R.id.data,R.id.Introduction}; /* * context:上下文对象 * data:数据源 List&lt;Map&lt;String,Object&gt;&gt; * resource:item对应的布局文件 * from:表示由map中定义的key组成的字符串类型的数组 * to:需要显示的控件id组成的int类型的数组 * 并且要保证from与to一一对应 */ sAdapter = new SimpleAdapter(MainActivity.this, list, R.layout.simple_adapter_item, from, to); //设置适配器进行显示 lv.setAdapter(sAdapter); }} 使用SimpleAdapter实现图文混排效果 效果预览： 代码实现： activity_main.xml 1234&lt;ListView android:id=\"@+id/lv\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt; simple_adapter_item.xml 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;ImageView android:id=\"@+id/pic_image\" android:layout_width=\"60sp\" android:layout_height=\"60sp\" android:src=\"@drawable/cjgl\"/&gt; &lt;TextView android:id=\"@+id/pic_name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_toRightOf=\"@+id/pic_image\" android:textSize=\"18sp\" android:layout_marginLeft=\"10dp\" android:text=\"场景管理\"/&gt; &lt;TextView android:id=\"@+id/pic_desc\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_toRightOf=\"@+id/pic_image\" android:layout_alignLeft=\"@+id/pic_name\" android:layout_alignBottom=\"@+id/pic_image\" android:textSize=\"16sp\" android:text=\"场景管理的具体内容\"/&gt;&lt;/RelativeLayout&gt; java 123456789101112131415161718192021222324252627282930313233343536373839public class MainActivity extends AppCompatActivity { private ListView lv; private SimpleAdapter sAdapter; private List&lt;Map&lt;String, Object&gt;&gt; list; private HashMap&lt;String, Object&gt; map; private int[] images = {R.drawable.cjgl,R.drawable.cndy, R.drawable.glsb,R.drawable.jcgl,R.drawable.jg, R.drawable.jsfw,R.drawable.kf,R.drawable.jdgl, R.drawable.qxsp,R.drawable.sbkf,R.drawable.zhqxgl}; private String[] names = {\"场景管理\",\"功能定义\",\"关联设备\",\"基础管理\",\"警告\", \"技术服务\",\"调试\",\"节点管理\",\"权限审批\",\"设备开发\",\"账号权限管理\"}; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化控件 lv = (ListView) findViewById(R.id.lv); //数据源初始化 list = new ArrayList&lt;Map&lt;String,Object&gt;&gt;(); for (int i = 0; i &lt; names.length; i++) { map = new HashMap&lt;String, Object&gt;(); map.put(\"img\", images[i]); map.put(\"name\", names[i]); map.put(\"desc\", names[i]+\"的具体说明\"); list.add(map); } //初始化Adapter String[] from = {\"img\",\"name\",\"desc\"}; int to[] = {R.id.pic_image,R.id.pic_name,R.id.pic_desc}; sAdapter = new SimpleAdapter(this, list, simple_layout_item, from, to); //设置适配器 lv.setAdapter(sAdapter); }} 3. 自定义适配器 自定义Adapter：开发过程中经常使用到的适配器对象，用来将动态变化的数据适配给ListView 实现步骤： 继承自BaseAdapter，实现里面的四个方法，getCount()，getItem()，getItemId()，getView() 通过代码将需要适配的数目指定，需要返回的View对象指定 LayoutInflater：布局映射器，通过from方法获取布局映射器对象，就可以调用该对象的inflate方法将一个xml文件转化成View对象 myadapter 123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:id=\"@+id/myadapter_tv\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textSize=\"20sp\" android:padding=\"8dp\" android:text=\"你好\"/&gt;&lt;/LinearLayout&gt; java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class MainActivity extends AppCompatActivity { private ListView lv; private List&lt;String&gt; list; private MyAdapter adapter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化控件 lv = (ListView) findViewById(R.id.lv); //数据源初始化 list = new ArrayList&lt;String&gt;(); for(int i=0;i&lt;40;i++){ list.add(\"数据\"+i); } //初始化适配器 adapter = new MyAdapter(); lv.setAdapter(adapter); } //实现自己的适配器 class MyAdapter extends BaseAdapter{ //计算需要适配的item的总数 @Override public int getCount() { return list.size(); } //获取每一个item对象 @Override public Object getItem(int position) { return list.get(position); } //获取每一个item的id值 @Override public long getItemId(int position) { return position; } //获取每一个item对应的View视图 @Override public View getView(int position, View view, ViewGroup viewGroup) { //获取布局映射对象 LayoutInflater inflater = LayoutInflater.from(MainActivity.this); //1. 将定义好的xml文件转化成View对象 View V = inflater.inflate(R.layout.my_adapter_item,null); //2. 给View对象中的控件进行赋值 //findViewById是通过View对象来调用的 TextView tv = V.findViewById(R.id.myadapter_tv); //赋值 tv.setText(list.get(position)); return V; } }} ArrayAdapter、SimpleAdaper与自定义Adapter区别： ListView的缓存优化List的工作原理： Adapter是ListView与数据之间的桥梁 ListView在开始绘制的时候，系统首先调用getCount(),根据其返回值得到ListView的长度，然后根据这个长度，调用getView()一行一行的绘制ListView的每一项。 当ListView的每一项将要显示时，都会调用Adapter的getView()方法，返回一个View ListView中有多少项，就调用多少次getView()方法去创建每一项的View，这一过程是耗时操作。 但这种绘制在item项目数很大的时候，性能会急剧下降，所以必须采用性能优化方法。 ListView的缓存原理： ListView先通过getView()的方法请求一个View，然后请求其他可见的View，convertView在getView中是空的（NULL） 当列表第一项滚出屏幕时，并且一个新的项从屏幕底端上来是，ListView会再请求一个View，这时，convertView已经不是空值了，它的值为滚出屏幕第一项，之后只需设定新的数据，然后返回convertView即可，而不必从新创建一个View。 如果一个屏幕中可以呈现N项item，系统会创建N+1个item 在每次item进行view呈现的时候，因为屏幕显示的item个数是有限的，所以只要有一个item滑出屏幕，那么必然有一个item要滑入屏幕，我们只需要将滑入屏幕的item呈现的View复用之前滑出的item对应View即可。 定义ViewHolder类，在类中定义item中需要复用的控件，然后在convertView创建的时候对应创建viewHolder对象，然后给定标签进行关联，下一次滑入的item只需取出这个标签进行控件的重写赋值即可。 1234567891011121314151617181920212223242526 //获取每一个item对应的View视图 //view：系统复用的视图 @Override public View getView(int position, View view, ViewGroup viewGroup) { Holder holder; //表示系统第一次运行 if (view == null) { view = LayoutInflater.from(MainActivity.this) .inflate(R.layout.my_adapter_item, null); holder = new Holder(); view.setTag(holder); holder.tv = (TextView) view.findViewById(R.id.myadapter_tv); //打标签，方便取出 view.setTag(holder); } else { //进行复用 holder = (Holder) view.getTag(); } //赋值 holder.tv.setText(list.get(position)); return view; }}class Holder{ TextView tv;} Android UI开发分类 界面布局开发——定义界面的布局 控件开发——定义单个界面元素 AdapterView与Adapter开发——列表显示（适配器的开发） UI组件开发——对话框、通知、菜单等 自定义View、图形图像和动画——通过代码，自行绘制界面。","link":"/2019/01/28/Android%E5%BC%80%E5%8F%91-%E9%80%82%E9%85%8D%E5%99%A8/"},{"title":"⑤Android开发-适配器（二）","text":"Spinner | GridView | ListView添加头和尾 | AutoCompleteTextView 4. SpinnerSpinner：用户选择列表，下拉列表。其内容都是文本信息，常用ArrayAdapter来填充。 有两种为Spinner加载数据的方式： 在XML中定义数据资源，使用ArrayAdapter。creatFromResource()方法吧该资源加载进来 直接在Java代码ArrayAdapter中使用.setAdapter方法 效果预览： 代码实现-1： 1234&lt;Spinner android:id=\"@+id/spinner\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt;&lt;/Spinner&gt; 123456789101112131415161718192021public class MainActivity extends AppCompatActivity { private Spinner spinner; private ArrayAdapter&lt;String&gt; adapter; private List&lt;String&gt; list; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化 spinner = findViewById(R.id.spinner); list = new ArrayList&lt;String&gt;(); for (int i = 0;i&lt;10;i++){ list.add(\"数据\"+i); } adapter = new ArrayAdapter&lt;String&gt;(this,android.R.layout.simple_expandable_list_item_1,list); //设置外观 //adapter.setDropDownViewResource(android.R.layout.simple_spinner_item); //设置适配器显示 spinner.setAdapter(adapter); }} 代码实现-2： values-datalist 12345678910&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;string-array name=\"datalist\"&gt; &lt;item&gt;北京&lt;/item&gt; &lt;item&gt;上海&lt;/item&gt; &lt;item&gt;广州&lt;/item&gt; &lt;item&gt;天津&lt;/item&gt; &lt;item&gt;武汉&lt;/item&gt; &lt;/string-array&gt;&lt;/resources&gt; 1234567891011121314&lt;Spinner android:id=\"@+id/spinner\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt;&lt;/Spinner&gt;&lt;TextView android:id=\"@+id/spinner_tv\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_below=\"@+id/spinner\" android:layout_marginTop=\"74dp\" android:layout_centerHorizontal=\"true\" android:textSize=\"20sp\" android:text=\"TextView\"/&gt; 1234567891011121314151617181920212223242526272829303132333435public class MainActivity extends AppCompatActivity { private Spinner spinner; private ArrayAdapter&lt;CharSequence&gt; adapterXML; private List&lt;String&gt; list; private TextView tv; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化 spinner = findViewById(R.id.spinner); tv = findViewById(R.id.spinner_tv); initByXML(); //设置spinner的选中item spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() { //AdapterView中item被选中的时候执行的方法 @Override public void onItemSelected (AdapterView&lt;?&gt; adapterView, View view, int i, long l) { tv.setText(adapterXML.getItem(i)); } //未选中的时候执行的方法 @Override public void onNothingSelected(AdapterView&lt;?&gt; adapterView) { } }); } private void initByXML() { adapterXML = ArrayAdapter.createFromResource (this,R.array.datalist,android.R.layout.simple_list_item_1); spinner.setAdapter(adapterXML); }} 5. GridViewGridView 是一个用表格显示资源的控件。其上显示的资源可以使用Adapter去填充，它可以在两个可滚动的方向上显示资源，由于它继承自AbsListVIew，所以填充的Adapter需要实现ListAdapter接口，使用BaseAdapter的子孙类都可以为GridView填充数据。 预览效果： 代码实现： activity_main.xml 注：android:numColumns=&quot;4&quot;为GridView的列数，另外可以利用android:listSelector=&quot;color/transparent&quot;取消/指定点击背景变化效果 12345&lt;GridView android:id=\"@+id/grid\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:numColumns=\"4\"&gt;&lt;/GridView&gt; grid_adapter_item.xml 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_gravity=\"center_horizontal\" android:layout_marginTop=\"10dp\" android:padding=\"10dp\" android:orientation=\"vertical\"&gt; &lt;ImageView android:id=\"@+id/grid_image\" android:layout_width=\"60dp\" android:layout_height=\"60dp\" android:src=\"@drawable/cjgl\"/&gt; &lt;TextView android:id=\"@+id/grid_name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:gravity=\"center_horizontal\" android:layout_marginTop=\"6dp\" android:textSize=\"16sp\" android:text=\"场景管理\"/&gt;&lt;/LinearLayout&gt; JavaClass-Myadapter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MyAdapter extends BaseAdapter { //定义数据源 private int[] images; private String[] names; private Context context; public MyAdapter(int[] images, String[] names, Context context) { this.images = images; this.names = names; this.context = context; } @Override public int getCount() { return names.length; } @Override public Object getItem(int i) { return null; } @Override public long getItemId(int i) { return 0; } @Override public View getView(int i, View view, ViewGroup viewGroup) { ViewHolder holder; if(view==null){ //将一个布局转化为View对象 view = LayoutInflater.from(context).inflate(R.layout.grid_adapter_item,null); holder = new ViewHolder(); holder.image = (ImageView) view.findViewById(R.id.grid_image); holder.name = (TextView) view.findViewById(R.id.grid_name); //打标签 view.setTag(holder); }else{ holder = (ViewHolder) view.getTag(); } //赋值 holder.image.setImageResource(images[i]); holder.name.setText(names[i]); return view; } class ViewHolder{ TextView name; ImageView image; }} MainActivity.java 1234567891011121314151617181920public class MainActivity extends AppCompatActivity { private GridView gridView; private int[] images = {R.drawable.cjgl,R.drawable.cndy, R.drawable.glsb,R.drawable.jcgl,R.drawable.jg, R.drawable.jsfw,R.drawable.kf,R.drawable.jdgl, R.drawable.qxsp,R.drawable.sbkf,R.drawable.zhqxgl}; private String[] names = {\"场景管理\",\"功能定义\",\"关联设备\",\"基础管理\",\"警告\", \"技术服务\",\"调试\",\"节点管理\",\"权限审批\",\"设备开发\",\"账号权限管理\"}; private MyAdapter adapter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化 gridView = (GridView) findViewById(R.id.grid); adapter = new MyAdapter(images,names,this); gridView.setAdapter(adapter); }} 6. ListView添加头和尾ListView添加头、尾，可以使用addHeader和addFooter， xml—&gt;view: 效果预览： 代码实现： activity_main.xml 1234&lt;ListView android:id=\"@+id/lv\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/ListView&gt; header.xml 1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;ImageView android:layout_width=\"match_parent\" android:layout_height=\"160dp\" android:src=\"@drawable/background\" android:scaleType=\"centerCrop\"/&gt;&lt;/LinearLayout&gt; fooer.xml 12345678910&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;Button android:id=\"@+id/footer\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"加载更多\"/&gt;&lt;/LinearLayout&gt; MainAcitvity.java 1234567891011121314151617181920212223242526272829303132333435public class MainActivity extends AppCompatActivity { private ListView lv; private ArrayAdapter&lt;String&gt; adapter; private List&lt;String&gt; list; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); lv = (ListView)findViewById(R.id.lv); //数据源初始化 list = new ArrayList&lt;String&gt;(); for(int i=0;i&lt;30;i++){ list.add(\"第\"+i+\"个数据\"); } //适配器初始化 adapter = new ArrayAdapter&lt;String&gt;(this,android.R.layout.simple_list_item_1,list); //xml---&gt;View View header = LayoutInflater.from(this).inflate(R.layout.header,null); //给listview添加对应header lv.addHeaderView(header); //方法一： 动态的给定控件 //Button footer = new Button(this); //footer.setText(\"加载更多\"); //方法二： 导入xml文件 View footer = LayoutInflater.from(this).inflate(R.layout.footer,null); //给ListView添加对应的footer lv.addFooterView(footer,null,true); //适配器显示 lv.setAdapter(adapter); }} 7. AutoCompleteTextView可以使用AutoCompleteTextView实现热门提示的效果，使用该控件类似于AdapterView的效果。 预览效果： 代码实现-1： 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:padding=\"10dp\" tools:context=\".MainActivity\"&gt; &lt;AutoCompleteTextView android:id=\"@+id/auto\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"/&gt;&lt;/RelativeLayout&gt; 12345678910111213public class MainActivity extends AppCompatActivity { private AutoCompleteTextView auto; private ArrayAdapter&lt;String&gt; adapter; private String[] tips = {\"aa\",\"aaa\",\"aaaa\",\"aaaaa\"}; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); auto = (AutoCompleteTextView) findViewById(R.id.auto); adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_expandable_list_item_1, tips); auto.setAdapter(adapter); }} 代码实现-2： 对于数据集，除了可以在Activity中声明一个Sting数组、List或者是Array以外，我们还可以写在android的资源文件中，通过资源文件来得到我们的数据集，例如：在res–&gt;values–&gt;strings.xml 这个文件中指定我们的数据集 12345678910&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;string-array name=\"datalist\"&gt; &lt;item&gt;123&lt;/item&gt; &lt;item&gt;12345&lt;/item&gt; &lt;item&gt;123456&lt;/item&gt; &lt;item&gt;124&lt;/item&gt; &lt;item&gt;1258&lt;/item&gt; &lt;/string-array&gt;&lt;/resources&gt; 然后在代码中，可以通过下面这种方式来创建Adapter对象： 1234private ArrayAdapter&lt;CharSequence&gt; adapter;adapter = ArrayAdapter.createFromResource(this, R.array.datalist,android.R.layout.simple_list_item_1);auto.setAdapter(adapter); 或者 123String[] tips2 = getResources().getStringArray(R.array.datalist);ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt; (this, android.R.layout.simple_list_item_1, countries2); 来实现效果，当我们输入两个字母时，就会有内容提示了，我们可以选择我们需要的选项，点击enter即可。 AutoCompleteTextView常用属性 属性 作用 android:completionHint 设置出现在下拉菜单中的提示标题 android:conpletionThreshold 设置用户至少输入多少个字符才会显示提示 android:dropDownHorizontalOffset 下拉菜单与文本框之间的水平偏移，默认与文本框左对齐 android:dropDownHeight 下拉菜单的高度 android:dropDownWidth 下拉菜单的宽度 android:singleLine 单行显示 Android UI开发分类 界面布局开发——定义界面的布局 控件开发——定义单个界面元素 AdapterView与Adapter开发——列表显示（适配器的开发） UI组件开发——对话框、通知、菜单等 自定义View、图形图像和动画——通过代码，自行绘制界面。","link":"/2019/02/11/Android%E5%BC%80%E5%8F%91-%E9%80%82%E9%85%8D%E5%99%A82/"},{"title":"⑨Android开发-网络通信","text":"Android网络通信基础 | 获取手机网络状态 | WebView的使用 Android网络通信基础 Android使用HTTP和Socket两种方式进行网络通信 包 说明 java.net 提供与网络通信相关的类，包括流和数据包socket、Interent协议和常见HTTP处理。该包是一个多功能网络资源，包含HttpURLContention接口。 java.io 虽然没有提供显示网络通信功能，但是仍然非常重要，该包中的类由其他Java包中提供的socket和链接使用。它们还用于与本地文件的交互。 java.nio 包含表示特定数据类型的缓冲区的类。适用于两个基于Java语言的端点之间的通信。 org.apache.* 表示许多为HTTP通讯提供精确控制和功能的包。可以将Apache视为流行的开源Web服务器。包含HTTPClient接口。 android.net 除核心java.net.*类以外，包含额外的网络访问socket。该包包括URI类，后者频繁用于Android应用程序开发，而不仅仅是传统的联网。 android.net.http 包含处理SSL证书的类。 获取手机的网络状态可以使用ConnectivityManager类来获取当前设备的网络状态，其主要作用如下： 监控网络状态（Wi-Fi、GPRS等） 操作的Type类型常用的有WiFi和GPRS两种 可以根据类型进行获取也可以获取当前活动的网络信息 1234567891011121314151617181920212223242526272829303132333435363738394041public class MainActivity extends AppCompatActivity { private TextView gprs; private TextView wifi; private ConnectivityManager manager; //网络连接管理对象 @SuppressLint(\"SetTextI18n\") @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); gprs = findViewById(R.id.gprs); wifi = findViewById(R.id.wifi); //管理器的初始化 manager = (ConnectivityManager) this.getSystemService(Context.CONNECTIVITY_SERVICE); //根据给定的网络类型获取该类型的网络连接信息 NetworkInfo.State gprsstate = manager.getNetworkInfo(ConnectivityManager.TYPE_MOBILE).getState(); NetworkInfo wifistate = manager.getNetworkInfo(ConnectivityManager.TYPE_WIFI); wifi.setText(\"当前的Wi-Fi连接状态为\"+wifistate.toString()); gprs.setText(\"当前的GPRS连接状态为\"+gprsstate.toString()); //如果当前没有网络连接 if(!gprsstate.equals(NetworkInfo.State.CONNECTED)){ Toast.makeText(MainActivity.this,\"当前无网络连接，稍后跳转至网络设置界面\",Toast.LENGTH_SHORT).show(); Timer timer = new Timer(); //延时执行任务 timer.schedule(new MyTask(),5000); } } //执行的任务类 class MyTask extends TimerTask{ @Override public void run() { //跳转到网络设置界面（隐式跳转） Intent intent = new Intent(); intent.setAction(Settings.ACTION_WIRELESS_SETTINGS); //无线网络设置连接 startActivity(intent); } }} WebView的使用用于显示web页面的View，在Activity中，WebView可以使用任何一个浏览器简易地显示一些Web内容，它使用Webkit绘图引擎去显示页面，它有如下两个重要方法： loadUrl(String url)：装载URL对应的网页。 setWebViewClient(WebViewClient client)：设置WebView客户端，实现客户端的行为。 在Android中，如果需要进行网页数据的访问，在底层中有一个高速浏览器引擎Webkit可以实现，Webkit是定义在核心系统库中的，没有办法直接进行访问，所以在SDK中封装了一个类WebView，可以调用。 即：如果在Android应用程序中需要进行网页的渲染访问，使用类WebView。 案例：简易版浏览器 代码实现： XML 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\".MainActivity\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\"&gt; &lt;EditText android:id=\"@+id/input\" android:layout_width=\"0dp\" android:layout_weight=\"1\" android:textSize=\"18dp\" android:layout_height=\"wrap_content\" android:hint=\"请输入网址\"/&gt; &lt;Button android:id=\"@+id/btn\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textSize=\"18dp\" android:text=\"跳转\"/&gt; &lt;/LinearLayout&gt; &lt;WebView android:id=\"@+id/wv\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt;&lt;/LinearLayout&gt; java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MainActivity extends AppCompatActivity { private EditText editText; private Button button; private WebView webView; String info; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); editText = findViewById(R.id.input); button = findViewById(R.id.btn); webView = findViewById(R.id.wv); //获取当前的输入内容，并且进行网页显示 button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { info = editText.getText().toString(); if(!TextUtils.isEmpty(info.trim())){ showPage(info); }else{ Toast.makeText(MainActivity.this,\"请检查输入\",Toast.LENGTH_SHORT).show(); } } }); } //显示页面方法 private void showPage(String info) { webView.loadUrl(info); //设置使用本地的客户端进行呈现 webView.setWebViewClient(new WebViewClient()); } //点击back按钮实现返回上一级页面，并如果没有上一级的时候，退出当前应用程序 //点击物理按钮 @Override public void onBackPressed() { //super.onBackPressed(); //如果WebView可以返回上一级 if(webView.canGoBack()){ webView.goBack(); }else{ super.onBackPressed(); } }}","link":"/2019/02/17/Android%E5%BC%80%E5%8F%91-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"title":"BLE开发-BLE协议栈及TI软件体系架构","text":"BLE协议栈架构 | GPA协议 | GATT协议 | TI BLE顶层软件体系架构 蓝牙是一种短距的无线通讯技术，可实现固定设备、移动设备之间的数据交换。一般将蓝牙3.0之前的BR/EDR蓝牙称为传统蓝牙，而将蓝牙4.0规范下的BLE蓝牙称为低功耗蓝牙。 BLE即蓝牙低能耗（Bluetooth Low Energy）也称低功耗蓝牙，是蓝牙技术联盟设计和销售的一种个人局域网技术，旨在用于医疗保健、运动健身、信标、安防、家庭娱乐等领域的新兴应用。相较经典蓝牙，低功耗蓝牙旨在保持同等通信范围的同时显著降低功耗和成本。从蓝牙4.0开始支持。蓝牙低功耗芯片有两种模式：单模和双模。 单模：只能执行低功耗协议栈，也就是只支持BLE。 双模：支持传统蓝牙以及BLE的使用。 特点： 低功耗，使用 BLE 与周围设备进行通讯时，其峰值功耗为传统蓝牙的一半 传输距离提升到 100 米 低延时，最短可在3 ms内完成连接并开始进行数据传输 缺点： 传输数据量较小，最大 512 个字节，超过 20 个字节需要分包处理 应用领域： 主要用于智能硬件，比如健康护理、运动和健身、设备电源管理等 1. BLE协议栈架构 协议有两个部分组成：Controller（控制器）和 Host（主机） Profiles和应用总是基于GAP和GATT之上 控制器与主机分离的形式来自标准的蓝牙 BR / EDR设备，这两个部分通常分别描述。任何 profiles（配置文件）和应用程序都是使用 GAP 与 GATT 层协议栈来编写程序。 如上图所述，要实现一个BLE应用，首先需要一个支持BLE射频的芯片，然后还需要提供一个与此芯片配套的BLE协议栈，最后在协议栈上开发自己的应用。可以看出BLE协议栈是连接芯片和应用的桥梁，是实现整个BLE应用的关键。那BLE协议栈具体包含哪些功能呢？简单来说，BLE协议栈主要用来对你的应用数据进行层层封包，以生成一个满足BLE协议的空中数据包，也就是说，把应用数据包裹在一系列的帧头（header）和帧尾（tail）中。具体来说，BLE协议栈主要由如下几部分组成： 1.1 控制器部分（Controller） 物理层 - PHY（Physical layer） 负责数据和语音的发送和接收，特点是短距离、低功耗。是一种带宽自适应跳频 GFSK（高斯频移键控），工作在免费的工业频段2.4GHz。PHY层做得好不好，直接决定整个BLE芯片的功耗，灵敏度以及selectivity等射频指标。 链路层 - LL（Link Layer） LL层是整个BLE协议栈的核心，也是BLE协议栈的难点和重点。像Nordic的BLE协议栈能同时支持20个link（连接），就是LL层的功劳。LL层要做的事情非常多，比如具体选择哪个射频通道进行通信，怎么识别空中数据包，具体在哪个时间点把数据包发送出去，怎么保证数据的完整性，ACK如何接收，如何进行重传，以及如何对链路进行管理和控制等等。LL层只负责把数据发出去或者收回来，对数据进行怎样的解析则交给上面的GAP或者ATT。 主机控制接口 - HCI（Host controller interface）。向上为主机提供软件应用程序接口（API），对外为外部硬件控制接口。该层可以通过一个可编程接口来实现，该可编程接口可以是 UART，SPI 或 USB。HCI是可选的（具体请参考文章： 三种蓝牙架构实现方案（蓝牙协议栈方案）），HCI主要用于2颗芯片实现BLE协议栈的场合，用来规范两者之间的通信协议和通信命令等。 1.2 主机部分（Host） 链路逻辑控制和适配协议层 - L2CAP层（Logic link control and adaptation protocol） L2CAP对LL进行了一次简单封装，LL只关心传输的数据本身，L2CAP就要区分是加密通道还是普通通道，同时还要对连接间隔进行管理。 安全管理层 - SMP（Secure manager protocol） SMP用来管理BLE连接的加密和安全的，如何保证连接的安全性，同时不影响用户的体验，这些都是SMP要考虑的工作。 属性协议层 - ATT（Attribute protocol）负责数据检索，允许一个设备暴露一些数据块给其他设备，其他设备称之为“属性”。简单来说，ATT层用来定义用户命令及命令操作的数据，比如读取某个数据或者写某个数据。BLE协议栈中，开发者接触最多的就是ATT。BLE引入了attribute概念，用来描述一条一条的数据。Attribute除了定义数据，同时定义该数据可以使用的ATT命令，因此这一层被称为ATT层。 通讯访问协议 - GAP（Generic access profile）是应用程配置文件的接口，用于 处理设备的发现和连接 相关的服务。GAP 还有处理安全连接等特征。是对LL层payload（有效数据包）如何进行解析的两种方式中的一种，而且是最简单的那一种。GAP简单的对LL payload进行一些规范和定义，因此GAP能实现的功能极其有限。GAP目前主要用来进行广播，扫描和发起连接等。GAP给设备定义了若干角色，其中主要的两个是：外围设备（Peripheral）和中心设备（Central）。 通用属性协议层 - GATT（Generic attribute profile ） GATT用来规范attribute中的数据内容，并运用group（分组）的概念对attribute进行分类管理，BLE 中所有的数据通信都需要经过GATT。没有GATT，BLE协议栈也能跑，但互联互通就会出问题，也正是因为有了GATT和各种各样的应用profile，BLE摆脱了ZigBee等无线协议的兼容性困境，成了出货量最大的2.4G无线通信产品。 它定义两个 BLE 设备通过叫做 Service 和 Characteristic 的东西进行通信。GATT 就是使用了 ATT 协议，ATT 协议把 Service, Characteristic遗迹对应的数据保存在一个查找表中，次查找表使用 16 bit ID 作为每一项的索引。 2. GAP协议GAP（Generic Access Profile）的缩写，中文是通用访问协议，它在用来控制设备连接和广播； GAP 使你的设备被其他设备可见，并决定了你的设备是否可以或者怎样与合同设备进行交互； 例如：Beacon 设备就只是向外广播，不支持连接，小米手环就等设备就可以与中心设备连接。 2.1 GAP广播数据在 GAP 中外围设备通过两种方式向外广播数据： Advertising Data Payload（广播数据）和 Scan Response Data Payload（扫描回复）； 每种数据最长可以包含 31 byte。这里广播数据是必需的，因为外设必需不停的向外广播，让中心设备知道它的存在； 扫描回复是可选的，中心设备可以向外设请求扫描回复，这里包含一些设备额外的信息，例如：设备的名字。 2.2 GAP广播的网络拓扑大部分情况下外围设备通过广播自己来让中心设备发现自己，并建立 GATT 连接，从而进行更多的数据交换； 也有些情况是不需要连接的，只要外设广播自己的数据即可，用这种方式主要目的是让外围设备，把自己的信息发送给多个中心设备； 因为基于 GATT 连接的方式的，只能是一个外设连接一个中心设备，使用广播这种方式最典型的应用就是苹果的 iBeacon。 2.3 GAP通信中角色GAP 给设备定义了若干角色，其中主要的两个是：外围设备（Peripheral - 从机 - 服务端）和 中心设备（Central - 主机 - 客户端）。 外围设备 - 从机：这一般就是非常小或者简单的低功耗设备，用来提供数据，并连接到一个更加相对强大的中心设备，例如小米手环； 中心设备 - 主机：中心设备相对比较强大，用来连接其他外围设备，例如手机等。 3. GATT协议GATT（Generic Attributes Profile）的缩写，中文是通用属性协议，是已连接的低功耗蓝牙设备之间进行通信的协议。一旦两个设备建立起了连接，GATT 就开始起作用了，这也意味着，你必需完成前面的GAP协议。 GATT使用了 ATT（Attribute Protocol）协议，ATT 协议把 Service，Characteristic 对应的数据保存在一个查找表中，查找表使用 16bit ID 作为每一项的索引。 GATT定义的多层数据结构简要概括起来就是 服务（Service） 可以包含多个 特征（Characteristic），每个特征包含 属性（Properties） 和 值（Value），还可以包含多个 描述（Descriptor）。 3.1 GATT结构 Profile（规范）： profile 可以理解为一种规范，一个标准的通信协议，它存在于蓝牙从机中（服务端）； 蓝牙组织规定了一些标准的 profile，例如 HID OVER GATT，防丢器，心率计等； 每个 profile 中会包含多个 service，每个 service 代表从机的一种能力。 Service（服务） service 可以理解为一个服务，在 BLE 从机中有多个服务，例如：电量信息服务、系统信息服务等； 每个 service 中又包含多个 characteristic 特征值； 每个具体的 characteristic 特征值才是 BLE 通信的主题，比如当前的电量是 80%，电量的 characteristic 特征值存在从机的 profile 里，这样主机就可以通过这个 characteristic 来读取 80% 这个数据。 Characteristic（特征） characteristic 特征，BLE 主从机的通信均是通过 characteristic 来实现，可以理解为一个标签，通过这个标签可以获取或者写入想要的内容。 UUID（通用唯一识别码） uuid 通用唯一识别码，我们刚才提到的 service 和 characteristic 都需要一个唯一的 uuid 来标识； 每个从机都会有一个 profile，不管是自定义的 simpleprofile，还是标准的防丢器 profile，他们都是由一些 service 组成，每个 service 又包含了多个 characteristic，主机和从机之间的通信，均是通过characteristic来实现。 3.2 GATT连接的网络拓扑一个外围设备（从机）只能连接一个中心设备（主机），而一个中心设备（主机）可以连接多个外围设备（从机），一旦建立起了连接，通信就是双向的了，对比前面的 GAP 广播的网络拓扑，GAP 通信是单向的，如果你要让两个设备外围设备（从机）之间能够通信，就只能通过中心设备（主机）中转。 3.3 GATT通信中角色从GATT的角度来看，处于连接状态时的两个设备，它们各自充当两种角色中的一种： 服务端（Server） 包含被GATT客户端读取或写入的特征数据的设备。 客户端（Client） 从GATT服务器中读取数据或向GATT服务器写入数据的设备。 外围设备（从机）作为 GATT 服务端（Server），它维持了 ATT 的查找表以及 service 和 characteristic 的定义，客户端和服务器的GATT角色独立于外围设备和中央设备的GAP角色。 外围设备可以是GATT客户端或GATT服务器，中心可以是GATT客户端或GATT服务器，一旦连接建立，外设将会给中心设备建议一个连接间隔（Connection Interval），这样中心设备就会在每个连接间隔尝试去重新连接，检查是否有新的数据； 但是，这个连接间隔只是一个建议，你的中心设备可能并不会严格按照这个间隔来执行，例如你的中心设备正在忙于连接其他的外设，或者中心设备资源太忙。 举例我相信很多人看了上面的介绍，还是不懂BLE协议栈的工作原理，以及每一层具体干什么的，为什么要这么分层。下面我以如何发送一个数据包为例来讲解BLE协议栈各层是如何紧密配合，以完成发送任务的。 如何通过无线发送一个数据包假设有设备A和设备B，设备A要把自己目前的电量状态83%（十六进制表示为0x53）发给设备B，该怎么做呢？作为一个开发者，他希望越简单越好，对他而言，他希望调用一个简单的API就能完成这件事，比如send(0x53)，实际上我们的BLE协议栈就是这样设计的，开发者只需调用send(0x53)就可以把数据发送出去了，其余的事情BLE协议栈帮你搞定。很多人会想，BLE协议栈是不是直接在物理层就把0x53发出去，就如下图所示： 这种方式初看起来挺美的，但由于很多细节没有考虑到，实际是不可行的。首先，它没有考虑用哪一个射频信道来进行传输，在不更改API的情况下，我们只能对协议栈进行分层，为此引入LL层，开发者还是调用send(0x53)，send(0x53)再调用send_LL(0x53,2402M)（注：2402M为信道频率）。这里还有一个问题，设备B怎么知道这个数据包是发给自己的还是其他人的，为此BLE引入access address概念，用来指明接收者身份，其中，0x8E89BED6这个access address比较特殊，它表示要发给周边所有设备，即广播。如果你要一对一的进行通信（BLE协议将其称为连接），即设备A的数据包只能设备B接收，同样设备B的数据包只能设备A接收，那么就必须生成一个独特的随机access address以标识设备A和设备B两者之间的连接。 广播方式我们先来看一下简单的广播情况，这种情况下，我们把设备A叫advertiser（广播者），设备B叫scanner或者observer（扫描者）。广播状态下设备A的LL层API将变成send_LL(0x53,2402M, 0x8E89BED6)。由于设备B可以同时接收到很多设备的广播，因此数据包还必须包含设备A的device address（0xE1022AAB753B）以确认该广播包来自设备A，为此send_LL参数需要变成(0x53,2402M, 0x8E89BED6, 0xE1022AAB753B)。LL层还要检查数据的完整性，即数据在传输过程中有没有发生窜改，为此引入CRC24对数据包进行检验 (假设为0xB2C78E) 。同时为了调制解调电路工作更高效，每一个数据包的最前面会加上1个字节的preamble（前导帧），preamble一般为0x55或者0xAA。这样，整个空中包就变成（注：空中包用小端模式表示！）： ![3-2](BLE开发-BLE协议栈及TI软件体系架构/3-2 .png) 上面这个数据包还有如下问题： 没有对数据包进行分类组织，设备B无法找到自己想要的数据0x53。为此我们需要在access address之后加入两个字段：LL header和长度字节。LL header用来表示数据包的LL类型，长度字节用来指明payload的长度 设备B什么时候开启射频窗口以接收空中数据包？如上图case1所示，当设备A的数据包在空中传输的时候，设备B把接收窗口关闭，此时通信将失败；同样对case2来说，当设备A没有在空中发送数据包时，设备B把接收窗口打开，此时通信也将失败。只有case3的情况，通信才能成功，即设备A的数据包在空中传输时，设备B正好打开射频接收窗口，此时通信才能成功，换句话说，LL层还必须定义通信时序。 当设备B拿到数据0x53后，该如何解析这个数据呢？它到底表示湿度还是电量，还是别的意思？这个就是GAP层要做的工作，GAP层引入了LTV（Length-Type-Value）结构来定义数据，比如020105，02-长度，01-类型（强制字段，表示广播flag，广播包必须包含该字段），05-值。由于广播包最大只能为31个字节，它能定义的数据类型极其有限，像这里说的电量，GAP就没有定义，因此要通过广播方式把电量数据发出去，只能使用供应商自定义数据类型0xFF，即04FF590053，其中04表示长度，FF表示数据类型（自定义数据），0x0059是供应商ID（自定义数据中的强制字段），0x53就是我们的数据(设备双方约定0x53就是表示电量，而不是其他意思)。 最终空中传输的数据包将变成： AA - D6BE898E - 60 - 0E - 3B75AB2A02E1 - 02010504FF590053 - 8EC7B2 AA – 前导帧(preamble) D6BE898E – 访问地址(access address) 60 – LL帧头字段(LL header) 0E – 有效数据包长度(payload length) 3B75AB2A02E1 – 广播者设备地址(advertiser address) 02010504FF590053 – 广播数据 8EC7B2 – CRC24值 有了PHY，LL和GAP，就可以发送广播包了，但广播包携带的信息极其有限，而且还有如下几大限制： 无法进行一对一通信 （广播是一对多通信，而且是单方向的通信） 由于不支持组包和拆包，因此无法传输大数据 通信不可靠。广播信道不能太多，否则将导致扫描端效率低下。为此，BLE只使用37(2402MHz) /38(2426MHz) /39(2480MHz)三个信道进行广播和扫描，因此广播不支持跳频。由于广播是一对多的，所以广播也无法支持ACK。这些都使广播通信变得不可靠。 扫描端功耗高。由于扫描端不知道设备端何时广播，也不知道设备端选用哪个频道进行广播，扫描端只能拉长扫描窗口时间，并同时对37/38/39三个通道进行扫描，这样功耗就会比较高。 而连接则可以很好解决上述问题，下面我们就来看看连接是如何将0x53发送出去的。 连接方式到底什么叫连接(connection)？像有线UART，很容易理解，就是用线（Rx和Tx等）把设备A和设备B相连，即为连接。用“线”把两个设备相连，实际是让2个设备有共同的通信媒介，并让两者时钟同步起来。蓝牙连接有何尝不是这个道理，所谓设备A和设备B建立蓝牙连接，就是指设备A和设备B两者“同步”成功，其具体包含以下几方面： 设备A和设备B对接下来要使用的物理信道达成一致 设备A和设备B双方建立一个共同的时间锚点，也就是说，把双方的时间原点变成同一个点 设备A和设备B两者时钟同步成功，即双方都知道对方什么时候发送数据包什么时候接收数据包 连接成功后，设备A和设备B通信流程如下所示： 如上图所示，一旦设备A和设备B连接成功（此种情况下，我们把设备A称为Master或者Central，把设备B称为Slave或者Peripheral），设备A将周期性以CI（connection interval）为间隔向设备B发送数据包，而设备B也周期性地以CI为间隔打开射频接收窗口以接收设备A的数据包。同时按照蓝牙spec要求，设备B收到设备A数据包150us后，设备B切换到发送状态，把自己的数据发给设备A；设备A则切换到接收状态，接收设备B发过来的数据。由此可见，连接状态下，设备A和设备B的射频发送和接收窗口都是周期性地有计划地开和关，而且开的时间非常短，从而大大减低系统功耗并大大提高系统效率。 现在我们看看连接状态下是如何把数据0x53发送出去的，从中大家可以体会到蓝牙协议栈分层的妙处。 对开发者来说，很简单，他只需要调用send(0x53) GATT层定义数据的类型和分组，方便起见，我们用0x0013表示电量这种数据类型，这样GATT层把数据打包成130053（小端模式！） ATT层用来选择具体的通信命令，比如读/写/notify/indicate等，这里选择notify命令0x1B，这样数据包变成了：1B130053 L2CAP用来指定connection interval（连接间隔），比如每10ms同步一次（CI不体现在数据包中），同时指定逻辑通道编号0004（表示ATT命令），最后把ATT数据长度0x0004加在包头，这样数据就变为：040004001B130053 LL层要做的工作很多，首先LL层需要指定用哪个物理信道进行传输（物理信道不体现在数据包中），然后再给此连接分配一个Access address（0x50655DAB）以标识此连接只为设备A和设备B直连服务，然后加上LL header和payload length字段，LL header标识此packet为数据packet，而不是control packet等，payload length为整个L2CAP字段的长度，最后加上CRC24字段，以保证整个packet的数据完整性，所以数据包最后变成： AAAB5D65501E08040004001B130053D550F6 AA – 前导帧(preamble) 0x50655DAB – 访问地址(access address) 1E – LL帧头字段(LL header) 08 – 有效数据包长度(payload length) 04000400 – ATT数据长度，以及L2CAP通道编号 1B – notify command 0x0013 – 电量数据handle 0x53 – 真正要发送的电量数据 0xF650D5 – CRC24值 虽然开发者只调用了 send(0x53)，但由于低功耗蓝牙协议栈层层打包，最后空中实际传输的数据将变成下图所示的模样，这就既满足了低功耗蓝牙通信的需求，又让用户API变得简单，可谓一箭双雕！ 上面只是对BLE协议栈实现原理做了一个简单概述，即便如此，由于都是关于BLE协议栈底层的东西，很多开发者还是会觉得比较枯燥和晦涩，而且对很多开发者来说，他们也不关心BLE协议栈是如何实现的，他们更关心的是BLE协议栈的使用，即怎么开发一个BLE应用。 4. TI BLE顶层软件体系架构 在顶层，CC2640 软件环境包括三个部分：实时操作系统（RTOS），应用和协议栈。 TI-RTOS 是一个实时的操作系统，具备多线程操作和任务同步等功能。 APP 应用和 BLE 协议栈作为单独的任务存在于 RTOS 中，BLE 协议栈具有最高优先级。间接访问（ICall）的消息框架被用于线程的同步和栈的通信： 协议栈：这包括低层的 BLE 协议栈链路层(LL)到 GAP 与 GAPP 的通信，如图1所示。大多数的 BLE 协议栈代码作为库提供。 应用：这包括相关的配置文件，应用程序，驱动程序，和 ICall 模块。 4.1 标准项目任务层次所有的项目都会包含至少三个实时操作系统的任务 Task。例如 simplebleperipheral 项目，这些任务是以及他们的任务优先级为： 5： BLE 协议栈的任务 3：GapRole 任务（从机角色） 1：应用任务（simplebleperipheral） 4.2 ICallICall（Indirect Call Framework）的调用可以实现应用程序的与 BLE 协议栈的通信（例如，线程同步）。 ICall 模块的源代码被包含在 IDE 的 应用工程的 “ICall” 与 “ICallBLE” 文件夹内。 IAR 如下（CCS 类似）： 4.2.1 ICall BLE 协议栈的服务 如图6的所示，ICall 可以监听协议栈（服务端）与应用程序（客户端）间的消息，注意不要把 ICall 的框架结构 与 BLE 中的 GATT 的 S/C 结构混淆，这样做的原因是为了方便应用软件与 RTOS 操作系统的升级，而不会互相耦合影响， 并且更方便把 CC254x 的代码已知道 CC2640 系列芯片上来。 本质上，当应用程序调用 BLE 协议栈的 API 函数时，由 ICall 发指令给 BLE 协议栈，反过来，协议栈发出来的消息也是 ICall 来传递的。 因为 ICall 模块是应用程序项目的一部分，应用程序可以直接访问 ICall 的函数。请注意，由于 BLE 协议栈具有最高优先级，因此应用程序任务将阻塞直到收到响应。应用程序阻塞期间，BLE 协议栈也可以异步地通过 ICall 通知应用程序某个消息（例如，事件更新）。 整理自： 深入浅出低功耗蓝牙(BLE)协议栈 [Leung_ManWah]CC2640学习笔记（3）——BLE协议栈及TI软件体系架构 [shunfa888]Android 蓝牙开发 —— BLE [RalfNick] 拓展： BLE GATT 介绍","link":"/2019/01/28/BLE%E5%BC%80%E5%8F%91-BLE%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%8F%8ATI%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/"},{"title":"⑥Android开发-适配器（三）","text":"实例：省市区三级联动 实例：省市区三级联动效果预览： 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\".MainActivity\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:padding=\"6dp\" android:layout_marginTop=\"30dp\" android:textSize=\"20dp\" android:text=\"请选择您的城市:\"/&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"40dp\"&gt; &lt;Spinner android:id=\"@+id/provinceSpinner\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\"/&gt; &lt;Spinner android:id=\"@+id/citySpinner\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\"/&gt; &lt;Spinner android:id=\"@+id/countySpinner\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\"/&gt; &lt;/LinearLayout&gt; &lt;TextView android:id=\"@+id/show\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"80dp\" android:textSize=\"20sp\" android:padding=\"6dp\" android:text=\"显示选中的城市\"/&gt;&lt;/LinearLayout&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114public class MainActivity extends AppCompatActivity { private Spinner provinceSpinner; //省 private Spinner citySpinner; //市 private Spinner countySpinner; //县（区） private TextView show; //用于显示的文本域 //省级选项 private String[] province = new String[]{\"北京\",\"上海\",\"天津\",\"广东\"}; //市级选项 private String[][] city = new String[][]{ {\"东城区\",\"西城区\",\"崇文区\",\"玄武区\"}, {\"长宁区\",\"静安区\",\"普陀区\",\"闸北区\"}, {\"和平区\",\"河东区\",\"河西区\",\"南开区\"}, {\"广州\",\"深圳\",\"韶关\"} }; //县（区）级选项 private String[][][] county = new String[][][]{ //北京 { {\"无\"},{\"无\"},{\"无\"},{\"无\"} }, //上海 { {\"无\"},{\"无\"},{\"无\"},{\"无\"} }, //天津 { {\"无\"},{\"无\"},{\"无\"},{\"无\"} }, //广东 { //广州 {\"珠海区\",\"荔湾区\",\"越秀区\",\"白云区\"}, //深圳 {\"宝安区\",\"福田区\",\"龙岗区\",\"罗湖区\"}, //韶关 {\"武江区\",\"浈江区\",\"曲江区\",\"乐昌区\"} } }; private ArrayAdapter&lt;String&gt; provinceAdapter; //省级适配器 private ArrayAdapter&lt;String&gt; cityAdapter; //市级适配器 private ArrayAdapter&lt;String&gt; countyAdapter; //县级适配器 private int provincePosition; //省级选中索引 private int cityPosition; //市级选中索引 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化 initViews(); } private void initViews() { //初始化控件 provinceSpinner = findViewById(R.id.provinceSpinner); citySpinner = findViewById(R.id.citySpinner); countySpinner = findViewById(R.id.countySpinner); show = findViewById(R.id.show); //初始化适配器及显示内容 provinceAdapter = new ArrayAdapter&lt;String&gt;(this,android.R.layout.simple_spinner_item,province); provinceSpinner.setAdapter(provinceAdapter); //省级下拉实现监听 provinceSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() { //需要在item选中省级的时候，动态的改变市级对应的显示 @Override public void onItemSelected(AdapterView&lt;?&gt; adapterView, View view, int i, long l) { cityAdapter = new ArrayAdapter&lt;String&gt;(MainActivity.this,android.R.layout.simple_spinner_item,city[i]); //设置二级下拉类表中选项内容适配器 citySpinner.setAdapter(cityAdapter); //记录当前的省级索引位置，留给下面修改县级进行适配使用 provincePosition = i; } @Override public void onNothingSelected(AdapterView&lt;?&gt; adapterView) { } }); //市级下拉监听 citySpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() { @Override public void onItemSelected(AdapterView&lt;?&gt; adapterView, View view, int i, long l) { countyAdapter = new ArrayAdapter&lt;String&gt;(MainActivity.this,android.R.layout.simple_spinner_item,county[provincePosition][i]); countySpinner.setAdapter(countyAdapter); show.setText(\"选中的城市为：\"+province[provincePosition]+city[provincePosition][i]); cityPosition = i; } @Override public void onNothingSelected(AdapterView&lt;?&gt; adapterView) { } }); //区级下拉监听 countySpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() { @Override public void onItemSelected(AdapterView&lt;?&gt; adapterView, View view, int i, long l) { show.setText(\"选中的城市为：\"+province[provincePosition]+city[provincePosition][cityPosition]+county[provincePosition][cityPosition][i]); } @Override public void onNothingSelected(AdapterView&lt;?&gt; adapterView) { } }); }} Android UI开发分类 界面布局开发——定义界面的布局 控件开发——定义单个界面元素 AdapterView与Adapter开发——列表显示（适配器的开发） UI组件开发——对话框、通知、菜单等 自定义View、图形图像和动画——通过代码，自行绘制界面。","link":"/2019/02/11/Android%E5%BC%80%E5%8F%91-%E9%80%82%E9%85%8D%E5%99%A83/"},{"title":"BLE开发-Android程序","text":"Ble Android 程序连接设备流程 1. 检查、开启权限1.1 声明权限1234&lt;uses-permission android:name=\"android.permission.BLUETOOTH\" /&gt;&lt;uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /&gt; android.permission.BLUETOOTH : 这个权限允许程序连接到已配对的蓝牙设备, 请求连接/接收连接/传输数据需要改权限, 主要用于对配对后进行操作; android.permission.BLUETOOTH_ADMIN : 这个权限允许程序发现和配对蓝牙设备, 该权限用来管理蓝牙设备, 有了这个权限, 应用才能使用本机的蓝牙设备, 主要用于对配对前的操作; android.permission.ACCESS_COARSE_LOCATION和android.permission.ACCESS_FINE_LOCATION：Android 6.0以后，这两个权限是必须的，蓝牙扫描周围的设备需要获取模糊的位置信息。这两个权限属于同一组危险权限，在清单文件中声明之后，还需要再运行时动态获取。 1`&lt;uses-feature android:name=``\"android.hardware.bluetooth_le\"` `android:required=``\"true\"``&gt;&lt;/uses-feature&gt;&lt;/uses-permission&gt;&lt;/uses-permission&gt;` android.hardware.bluetooth_le：声明此应用仅适用于具有低功耗蓝牙设备，若想适用于不支持BLE的设备，required设置为false 1.2 申请权限并在activity中动态申请权限（本例使用RxPermission请求权限） 1234567891011121314151617181920212223242526272829//请求定位权限private void checkPermission() { new RxPermissions((Activity)mContext).request(Manifest.permission.ACCESS_COARSE_LOCATION).subscribe(new Observer&lt;boolean&gt;() { @Override public void onSubscribe(Disposable d) { } @Override public void onNext(Boolean granted) { if (granted) { initBlueTooth(); } else { // 未获取权限 Toast.makeText(mContext, \"未获取定位权限\", Toast.LENGTH_LONG).show(); } } @Override public void onError(Throwable e) { } @Override public void onComplete() { } });} 2. 搜索设备搜索蓝牙设备是需要一个BluetoothAdapter来扫描设备的，这里又要进行设备是否支持蓝牙功能的判断和是否开启蓝牙（若未开启，提示用户或强制开启蓝牙） 2.1 检查是否开启蓝牙12345678910111213141516171819202122private void initBlueTooth() { //BluetoothAdapter代表设备自己的蓝牙适配器（蓝牙无线电） BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE); mBluetoothAdapter = bluetoothManager.getAdapter(); //设备是否支持蓝牙 if (mBluetoothAdapter == null) { Toast.makeText(mContext, \"该设备不支持蓝牙功能\", Toast.LENGTH_LONG).show(); finish(); } //蓝牙是否启用，若未启用，请求用户启用 if (!mBluetoothAdapter.isEnabled()) { Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT); return; } //若开启蓝牙，直接扫描低功耗蓝牙设备；若未开启，提示用户开启，用户开启后在onActivityResult开启扫描 scanLeDevice(true); } 2.2 扫描设备注意：扫描不能一直进行，本例SCAN_PERIOD=10000毫秒后停止扫描 1234567891011121314151617181920212223242526272829303132/** * 扫描低功耗蓝牙设备 * 您只能扫描蓝牙LE设备或扫描经典蓝牙设备，如蓝牙中所述 您无法同时扫描Bluetooth LE和传统设备。 * @param enable */private void scanLeDevice(final boolean enable) { if (enable) { //Because scanning is battery-intensive, you should observe the following guidelines: //As soon as you find the desired device, stop scanning.找到所需设备停止扫描 //Never scan on a loop, and set a time limit on your scan.切勿扫描循环，并在扫描上加上时间限制 mHandler.postDelayed(new Runnable() { @Override public void run() { mScanning = false; mBluetoothAdapter.stopLeScan(mLeScanCallback); mTextView.setText(\"扫描结束\"); invalidateOptionsMenu(); } }, SCAN_PERIOD); mScanning = true; //如果只想扫描特定类型的外设，则可以改为调用startLeScan（UUID []，BluetoothAdapter.LeScanCallback） //提供指定您的应用程序支持的GATT服务的UUID对象数组 mBluetoothAdapter.startLeScan(mLeScanCallback); mTextView.setText(\"扫描中...\"); } else { mScanning = false; mBluetoothAdapter.stopLeScan(mLeScanCallback); mTextView.setText(\"扫描结束\"); } invalidateOptionsMenu();} mBluetoothAdapter.startLeScan()的参数mLeScanCallback是扫描结果的回调，其中mDeviceListAdapter为列表适配器，mDevices为列表适配器中的数据，若不进行同一设备的过滤，会返回很多相同设备。 1234567891011121314151617mLeScanCallback = new BluetoothAdapter.LeScanCallback() { @Override public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) { runOnUiThread(new Runnable() { @Override public void run() { if (device != null) { // 过滤同一设备 if (!mDevices.contains(device)) { //将设备添加到列表中 mDeviceListAdapter.addData(device); } } } }); }}; 3. 连接BLE设备本demo是基于谷歌的示例代码，就直接将谷歌连接设备的相关类拷过来了，这里直接对其分析 在activity中绑定一个BluetoothLeService服务，此服务是用于对指定蓝牙设备进行连接或数据通信的服务 12Intent gattServiceIntent = new Intent(this, BluetoothLeService.class);bindService(gattServiceIntent, mServiceConnection, BIND_AUTO_CREATE); 其中mServiceConnection管理BluetoothLeService服务的生命周期 123456789101112131415161718192021/** * 管理蓝牙服务的生命周期 */private final ServiceConnection mServiceConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName componentName, IBinder service) { mBluetoothLeService = ((BluetoothLeService.LocalBinder) service).getService(); if (!mBluetoothLeService.initialize()) { Log.e(TAG, \"Unable to initialize Bluetooth\"); finish(); } //成功启动初始化后自动连接到设备 mBluetoothLeService.connect(mDeviceAddress); } @Override public void onServiceDisconnected(ComponentName componentName) { mBluetoothLeService = null; }}; 在连接设备之前，要判断设备是否支持低功耗蓝牙 123456789101112131415161718public boolean initialize() { // For API level 18 and above, get a reference to BluetoothAdapter through // BluetoothManager. if (mBluetoothManager == null) { mBluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE); if (mBluetoothManager == null) { Log.e(TAG, \"Unable to initialize BluetoothManager.\"); return false; } } mBluetoothAdapter = mBluetoothManager.getAdapter(); if (mBluetoothAdapter == null) { Log.e(TAG, \"Unable to obtain a BluetoothAdapter.\"); return false; } return true;} BluetoothLeService绑定成功后，将要连接的设备地址传入，在service中连接设备 12345678910111213141516171819202122232425262728293031323334353637/** * 连接到Bluetooth LE设备上托管的GATT服务器 * * @param address 设备地址 * @return 返回是否连接是否成功启动（注意：是启动，并不是连接结果） * 连接结果是在BluetoothGattCallback onConnectionStateChange异步返回的 */public boolean connect(final String address) { if (mBluetoothAdapter == null || address == null) { Log.w(TAG, \"BluetoothAdapter not initialized or unspecified address.\"); return false; } // 以前连接的设备，尝试重连 if (mBluetoothDeviceAddress != null &amp;&amp; address.equals(mBluetoothDeviceAddress) &amp;&amp; mBluetoothGatt != null) { Log.d(TAG, \"Trying to use an existing mBluetoothGatt for connection.\"); if (mBluetoothGatt.connect()) { mConnectionState = STATE_CONNECTING; return true; } else { return false; } } //通过传入的设备地址获取设备 final BluetoothDevice device = mBluetoothAdapter.getRemoteDevice(address); if (device == null) { Log.w(TAG, \"Device not found. Unable to connect.\"); return false; } // 我们要直接连接到设备，所以我们正在设置autoConnect参数为false （此处autoConnect为true可能不是立即连接） mBluetoothGatt = device.connectGatt(this, false, mGattCallback); Log.d(TAG, \"Trying to create a new connection.\"); mBluetoothDeviceAddress = address; mConnectionState = STATE_CONNECTING; return true;} 其中device.connectGatt（）的第三个参数mGattCallback为蓝牙设备与GATT服务端连接和数据通信的监听，此方法的返回值mBluetoothGatt 稍后介绍 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() { //回调指示何时GATT客户端连接到远程GATT服务器/从远程GATT服务器断开连接 @Override public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) { String intentAction; //连接成功 if (newState == BluetoothProfile.STATE_CONNECTED) { intentAction = ACTION_GATT_CONNECTED; mConnectionState = STATE_CONNECTED; broadcastUpdate(intentAction); Log.i(TAG, \"Connected to GATT server.\"); // 连接成功后尝试发现服务 Log.i(TAG, \"Attempting to start service discovery:\" +mBluetoothGatt.discoverServices()); } else if (newState == BluetoothProfile.STATE_DISCONNECTED) { intentAction = ACTION_GATT_DISCONNECTED; mConnectionState = STATE_DISCONNECTED; Log.i(TAG, \"Disconnected from GATT server.\"); broadcastUpdate(intentAction); } } //发现新服务时调用回调 @Override public void onServicesDiscovered(BluetoothGatt gatt, int status) { if (status == BluetoothGatt.GATT_SUCCESS) { broadcastUpdate(ACTION_GATT_SERVICES_DISCOVERED); } else { Log.w(TAG, \"onServicesDiscovered received: \" + status); } } //回调报告特征性读取操作的结果 @Override public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) { if (status == BluetoothGatt.GATT_SUCCESS) { broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic); } } //由于远程特征通知而触发的回调 @Override public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) { broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic); } }; 其中，连接成功、断开或发现服务或数据通信的回调均发送了广播，在activity中接收广播进行管理，这里先不关注每一个方法，尽量从一个流程分析 看到onConnectionStateChange回调中，判断状态为连接成功，调用了如下代码发现服务 1`mBluetoothGatt.discoverServices()` 注意： 上文中mBluetoothGatt相当于手机与设备通信的管道通过BluetoothGatt 发现服务（discoverServices） 获取服务（getServices） 开启指定指定特征的通知（setCharacteristicNotification） 对指定特征写入数据（writeCharacteristic） 把相应地属性返回到BluetoothGattCallback Demo中发现服务后发送广播到activity中，在activity中接收广播调用service（此service为BluetoothLeService，是自己写的对指定蓝牙设备进行连接或数据通信的服务）的获取服务（此处的服务为蓝牙设备所拥有的服务BluetoothGattService）方法getServices，然后在activity中对服务进行遍历，并存储每个服务下的特征值 此处分析下流程：调用mBluetoothGatt.discoverServices方法后，发现服务后会回调给BluetoothGattCallback的onServicesDiscovered，在调用mBluetoothGatt.getServices()返回一个包含BluetoothGattService服务的集合，再对集合进行遍历，获取每一个BluetoothGattService服务的特征 注意：（这里有点绕） BluetoothLeService 自己写的对指定蓝牙设备进行连接或数据通信的服务 BluetoothGattService 蓝牙设备所拥有的服务 BluetoothGattCharacteristic 某一BluetoothGattService的某一特征 BluetoothGattDescriptor 某一BluetoothGattCharacteristic下的属性，用来描述characteristic变量的属性 下面这张图为BluetoothGattService 和 BluetoothGattCharacteristic 和 BluetoothGattDescriptor的关系 遍历服务（这里尤其绕）使用了ExpandableListView展示服务和服务下的特征 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758private void displayGattServices(List&lt;bluetoothgattservice&gt; gattServices) { if (gattServices == null) return; String uuid = null; String unknownServiceString = getResources().getString(R.string.unknown_service); String unknownCharaString = getResources().getString(R.string.unknown_characteristic); ArrayList&lt;hashmap&lt;string, string=\"\"&gt;&gt; gattServiceData = new ArrayList&lt;hashmap&lt;string, string=\"\"&gt;&gt;(); ArrayList&gt;&gt; gattCharacteristicData = new ArrayList&gt;&gt;(); mGattCharacteristics = new ArrayList&gt;(); //遍历所有的服务 for (BluetoothGattService gattService : gattServices) { //每一个服务的name 和 UUID保存在map中 HashMap&lt;string, string=\"\"&gt; currentServiceData = new HashMap&lt;string, string=\"\"&gt;(); uuid = gattService.getUuid().toString(); currentServiceData.put( LIST_NAME, SampleGattAttributes.lookup(uuid, unknownServiceString)); currentServiceData.put(LIST_UUID, uuid); //将每一个包含服务信息的map 都添加到集合中 gattServiceData.add(currentServiceData); ArrayList&lt;hashmap&lt;string, string=\"\"&gt;&gt; gattCharacteristicGroupData = new ArrayList&lt;hashmap&lt;string, string=\"\"&gt;&gt;(); List&lt;bluetoothgattcharacteristic&gt; gattCharacteristics = gattService.getCharacteristics(); ArrayList&lt;bluetoothgattcharacteristic&gt; charas = new ArrayList&lt;bluetoothgattcharacteristic&gt;(); //遍历服务中的特征 for (BluetoothGattCharacteristic gattCharacteristic : gattCharacteristics) { //将此服务中的特征添加到集合中 charas.add(gattCharacteristic); //将此特征的UUID和name保存在map中 HashMap&lt;string, string=\"\"&gt; currentCharaData = new HashMap&lt;string, string=\"\"&gt;(); uuid = gattCharacteristic.getUuid().toString(); currentCharaData.put(LIST_NAME, SampleGattAttributes.lookup(uuid, unknownCharaString)); currentCharaData.put(LIST_UUID, uuid); //将每一个包含特征信息的map 都添加到集合中 gattCharacteristicGroupData.add(currentCharaData); } //将每个服务中包含的所有特征的集合添加到总集合中 mGattCharacteristics.add(charas); //将每个服务中包含的所有特征信息的集合添加到总集合中 gattCharacteristicData.add(gattCharacteristicGroupData); } SimpleExpandableListAdapter gattServiceAdapter = new SimpleExpandableListAdapter( this,gattServiceData, android.R.layout.simple_expandable_list_item_2, new String[]{LIST_NAME, LIST_UUID}, new int[] {android.R.id.text1,android.R.id.text2}, gattCharacteristicData, android.R.layout.simple_expandable_list_item_2, new String[]{LIST_NAME, LIST_UUID}, new int[]{android.R.id.text1, android.R.id.text2}); mGattServicesList.setAdapter(gattServiceAdapter); } 上面的代码如果不太明白可以慢慢看的，先看下面的我们只需要知道，点击ExpandableListView group为此设备下的所有service，点击group会展开此service下的所有特征： 1234567891011121314151617181920212223//ExpandableListView 子条目点击监听 点击条目，会把正在通信的特征关闭通知，再把点击条目的特征打开通知private final ExpandableListView.OnChildClickListener servicesListClickListener = new ExpandableListView.OnChildClickListener() { @Override public boolean onChildClick(ExpandableListView parent, View v, int groupPosition, int childPosition, long id) { if (mGattCharacteristics != null) { final BluetoothGattCharacteristic characteristic = mGattCharacteristics.get(groupPosition).get(childPosition); // 正常流程 // 打开指定接收特征（指定UUID）通知 // 在指定写入特征写入数据 // 从指定UUID的特征打开接收（测试用） if (characteristic.getUuid().toString().equals(\"0000ff02-0000-1000-8000-00805f9b34fb\")) { mBluetoothLeService.setCharacteristicNotification(characteristic, true); } // 从指定UUID的特征写入（测试用） if (characteristic.getUuid().toString().equals(\"0000ff01-0000-1000-8000-00805f9b34fb\")) { mBluetoothLeService.write(characteristic); } return true; } return false; }}; 本例中UUID为0000ff02-0000-1000-8000-00805f9b34fb的特征为读取特征UUID为0000ff01-0000-1000-8000-00805f9b34fb的特征为写入特征 点击0000ff02-0000-1000-8000-00805f9b34fb条目打开读取通知 1`mBluetoothGatt.setCharacteristicNotification(characteristic, enabled);` 点击0000ff01-0000-1000-8000-00805f9b34fb条目写入数据 1234567891011//写入数据（测试用） public void write(BluetoothGattCharacteristic characteristic) { //握手 characteristic.setValue(hexStringToByteArray(\"A2\")); mBluetoothGatt.writeCharacteristic(characteristic); //握手和命令不能超过4秒，但又不能马上 SystemClock.sleep(500); //命令 characteristic.setValue(\"SINSAM\"); mBluetoothGatt.writeCharacteristic(characteristic); } 数据写入后，就会在mGattCallback的onCharacteristicRead回调里通过characteristic.getValue()拿到数据了 文章 作者：陈利健 链接：https://www.jianshu.com/p/795bb0a08beb","link":"/2019/02/27/BLE%E5%BC%80%E5%8F%91-Android%E7%A8%8B%E5%BA%8F/"},{"title":"C++标准模板库STL(二)","text":"STL是Standard Template Library的简称，中文名标准模板库，惠普实验室开发的一系列软件的统称。从根本上说，STL是一些“容器”的集合，这些“容器”有list,vector,set,map等，STL也是算法和其他一些组件的集合。这里的“容器”和算法的集合指的是世界上很多聪明人很多年的杰作。STL的目的是标准化组件，这样就不用重新开发，可以使用现成的组件。STL是C++的一部分，因此不用安装额外的库文件。 C++ setset翻译为集合，是一个内部自动有序且不含重复元素的容器。在考试中有可能出现需要去掉重复元素的情况，而且有可能因这些元素比较大或者类型不是int而不能直接开散列表，在这种情况下可以用set来保留元素本身而不考虑它的个数。当然上面所说的情况也可以通过再开一个数组进行下标和元素的对应来解决，但是set提供了更为直观的接口，并且可以实现自动排序。 使用set需要引入set头文件#include &lt;set&gt;。还需要在头文件下加一加using namespace std； set 的定义单独定义一个set 1set&lt;typename&gt; set; 其定义与vector是基本一样的，或者说大部分的STL都是这样定义的，这里的typename依然可以是任何基本类型、结构体、STL标准容器等。 123set&lt;int&gt; name;set&lt;node&gt; name; // 结构体set&lt;set&lt;int&gt; &gt; name; // 记得加空格 数组定义与vector相同 1set&lt;typename&gt; Arrayname[arraySize]; set 容器元素的访问set只能通过迭代器（iterator）访问： 1set&lt;int&gt;::iterator it; 由于除了vector和string之外的STL容器都不支持*(it+i)的方式访问，因此只能按照以下方式枚举： 12345678910111213141516#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;int main(){ set&lt;int&gt; st; st.insert(3); // insert(x) -- 将x插入set中 st.insert(5); st.insert(2); st.insert(3); // 注：不支持it &lt; st.end()的写法 for(set&lt;int&gt;::iterator it = st.begin(); it != st.end(); it++){ printf(\"%d \", *it); } return 0;} 输出： 12 3 5 可以发现set内元素自动排序并且去掉了重复元素。 set 常用函数实例解析 insert() 可以将x插入set容器中，并自动递增排序和去重，时间复杂度O(logN)。 find() 返回set中对于值为value的迭代器，时间复杂度为O(logN) 12345678910111213#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;int main(){ set&lt;int&gt; st; for(int i = 1; i &lt;= 3; i++){ st.insert(i); } set&lt;int&gt;::iterator it = st.find(2); printf(\"%d\",*it); // 也可以写成 printf(\"%d\",*(st.find(2)));} erase() 有两个用法 删除单个元素 st.erase(it)，it为所需要删除元素的迭代器，时间复杂度为O(1)，可以结合find()函数使用. st.erase(value)，value为所需要删除元素的值，时间复杂度为O(logN)。 删除一个区间内所有的元素 erase(first,last)，可以删除(first,last]直接的元素，时间复杂度为O(first-last) size() 获取set容器内元素的个数，时间复杂度为O(1)。 clear() 清空set内所有的元素，时间复杂度为O(N)。 set 的常见用途set的最主要用途是自动去重并按照升序排序 延伸：set中元素是惟一的，如果需要处理不唯一的情况，则需要使用multiset。另外，C++ 11标志中还增加了unordered_set，以散列表set内部的红黑树（Red Black Tree，一种自平衡二叉查找树）实现，使其可以用来处理只去重但不排序的需求，速度比set要快很多。 C++ queuequeue翻译为队列，在STL中主要实现了先进先出的容器。 12#include &lt;queue&gt;using namespace std; queue定义1queue&lt;typename&gt; name; queue容器内元素的访问由于队列本身就是一种先进先出的限制性数据结构，因此在STL中只能通过front来访问队首元素，或者是通过back()来访问队尾元素。 123456789101112#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;int main(){ queue&lt;int&gt; q; for (int i = 1; i &lt;= 5; i++){ q.push(i); } printf(\"%d %d\",q.front(),q.back()); return 0;} 常用函数解析 push() push(x)将x进行入队。 front() back() 获得队首 队尾元素 pop() 令队首元素出队 empty() 监测queue是否为空，返回true-空，false-非空 size() 返回queue内元素个数。 queue 常见用途需要实现广度优先搜索时，可以不用自己手动实现一个队列，而是用queue作为代替。 注：使用front()和pop()前，必须用empty()判断队列是否为空，否则可能因为队空而出现错误。 延伸：STL容器中还有两种容器与队列有关，分别是双端队列（deque）和优先队列（priority_queue），前者是首位皆可插入和删除队列，后者是使用堆实现的默认将当前队列最大元素置于队首。 priority_queue 优先队列priority_queue又称为优先队列，其底层是利用堆来进行实现的。在优先队列中，队首元素一定是当前队列中优先级别最高的一个，例如： 桃子（4） 香蕉（3） 苹果（1） 出队顺序为桃子–&gt;香蕉–&gt;苹果，这里的优先级是规定出来的，也可以数字越小优先级越大。 priority_queue 的定义要用优先队列必须： 12#include &lt;queue&gt;using namespace std; 定义方法： 1priority_queue&lt;typename&gt; name; priority_queue 容器内元素的访问和队列不一样的是，优先队列没有front()函数与back()函数，而只能通过top()函数来访问队首元素（也可以称为堆顶元素）也就是优先级最高的元素。 12345678910111213#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;int main(){ priority_queue&lt;int&gt; q; q.push(5); q.push(7); q.push(16); if(!q.empty()){ printf(\"%d\\n\",q.top()); }} priority_queue 常用函数实例解析 push() 将令x入队 top() 可以访问队首元素（即堆顶元素） pop() 令队首元素（即堆顶元素）出队 empty() 检测优先队列是否为空，true–空，false–非空 size() 返回优先队列内元素个数 priority_queue 内元素优先级设置如何定义优先队列内元素的优先级是运用好优先队列的关键，优先级设置方法如下： 基本数据类型的优先级设置 基本数据类型即int型、double型、char型等，优先队列对他们的优先级设置一般是数字大的优先级越高（char型是字典序越大的）,如下两种优先队列的定义是等价的： 12priority_queue&lt;int&gt; q;priority_queue&lt;int, vector&lt;int&gt;,less&lt;int&gt; &gt; q; 可以发现，第二种定义方式的尖括号内多出了两个参数：一个是vector&lt;int&gt;，是承载底层数据结构堆（heap）的容器，另一个是less&lt;int&gt;，是对第一个参数的比较类，less&lt;int&gt;表示数字越大优先级越大，而greater&lt;int&gt;表示数字越小优先级越大。 因此要想让优先队列总是把最小的元素放在队首，只需要进行如下定义： 1priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; 例如： 12345678910111213#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;int main(){ priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; q.push(5); q.push(7); q.push(16); if(!q.empty()){ printf(\"%d\\n\",q.top()); }} 结构体的优先级设置 本节开头举了一个水果的例子，可以对水果名称和价格建立一个结构体，如下： 1234struct fruit{ string name; int price;}; 现在希望按水果的价格的高为优先级高，就需要重载（overload）小于号“&lt;”。重载是指对已有的运算符进行重新定义，也就是说，可以改变小于号的功能： 123456struct fruit{ string name; friend bool operator &lt; (fruit f1, friut f2){ return fi.price &lt; f2.price; }} 由此，friend结构体中增加了一个函数，其中friend为有元，后面的bool operator&lt;(fruit f1, friut f2&gt;)对fruit类型的操作符“&lt;”进行重载（重载大于号会编译错误，因为从数学上来说，只需要重载小于号，即f1&gt;f2等价于判断f2&lt;f1，而f1==f2等价于判断!(f1&lt;f2)&amp;&amp;!(f2&lt;f1）），函数部分return f1.price &lt; f2.price，因此重载后小于号还是小于号的作用。此次就可以直接定义fruit优先队列： 1priority_queue&lt;fruit&gt; q; 如果想要以价格低的水果为优先级高： 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;string&gt;using namespace std;struct fruit{ string name; int price; friend bool operator &lt; (fruit f1, fruit f2){ return f1.price &gt; f2.price; }};int main(){ fruit f1, f2, f3; priority_queue&lt;fruit&gt; q; f1.name = \"香蕉\"; f1.price = 3; f2.name = \"猕猴桃\"; f2.price = 4; f3.name = \"葡萄\"; f3.price = 6; q.push(f1); q.push(f2); q.push(f3); if(!q.empty()){ fruit p = q.top(); cout &lt;&lt; p.name &lt;&lt; \" \" &lt;&lt; p.price &lt;&lt; endl; } return 0;} 优先队列的这个函数与sort中的cmp的效果是相反的，也可以和cmp函数一样写在外面，需要把friend去掉，把小于号改成一对小括号，然后把重写函数写在结构体外面，同时将其用struct包装起来： 12345struct cmp{ bool operator () (fruit f1, fruit f2){ return f1.price &gt; f2.price; }} 此时可以通过： 1priority_queue&lt;fruit, vector&lt;fruit&gt;, cmp &gt;q; 来实现，例如： 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;string&gt;using namespace std; struct fruit{ string name; int price;};struct cmp{ bool operator () (fruit f1, fruit f2){ return f1.price &gt; f2.price; }}; int main(){ fruit f1, f2, f3; // priority_queue&lt;fruit&gt; q; priority_queue&lt;fruit, vector&lt;fruit&gt;, cmp&gt; q; f1.name = \"香蕉\"; f1.price = 3; f2.name = \"猕猴桃\"; f2.price = 4; f3.name = \"葡萄\"; f3.price = 6; q.push(f1); q.push(f2); q.push(f3); if(!q.empty()){ fruit p = q.top(); cout &lt;&lt; p.name &lt;&lt; \" \" &lt;&lt; p.price &lt;&lt; endl; } } 同理，基本数据类型或者其他是STL容器（例如set），也可以使用这样的方式来定义优先级。 如果结构体的数据比较庞大（例如出现了字符串或数组），建议使用引用来提高效率，此时比较类的参数中需要加上const和&amp; 123456friend bool operator &lt; (const fruit &amp;f1, const fruit &amp;f2){ return f1.price &gt; f2. price;}bool operator () (const fruit &amp;f1, const fruit &amp;f2){ return f1.price &gt; f2.price;} priority_queue 的常见用途priority_queue可以解决一些贪心问题，也可以对Dijkstra算法进行优化（因为优先队列的本质是堆）。 注：使用top()前，必须用empty()判断优先队列是否为空，否则可能因为队空而出现错误。 C++ stackstuck翻译为栈，是STL中一种后进先出的容器。 stack 的定义声明： 12#include &lt;stack&gt;using namespace std; 定义： 1stack&lt;typename&gt; name; stack 容器内元素的访问由于栈（stack）本身就是一种先进后出的数据结构，在STL的stack中只能通过top()来访问栈顶元素： stack 常用函数解析 push() top() pop() empty() size() stack 常见用途用来模拟实现一些递归，放置程序对栈内存的限制而导致程序出错。一般来说，程序栈的内存空间很小，对有些题目来说，如果用普通的函数进行递归，一旦递归层数过深（不同机器不同，约几千至几万层）则会导致程序运行崩溃。如果用stack来模拟递归算法实现，可以避免这一问题。","link":"/2019/12/20/C-STL-2/"},{"title":"C++标准模板库STL(一)","text":"STL是Standard Template Library的简称，中文名标准模板库，惠普实验室开发的一系列软件的统称。从根本上说，STL是一些“容器”的集合，这些“容器”有list,vector,set,map等，STL也是算法和其他一些组件的集合。这里的“容器”和算法的集合指的是世界上很多聪明人很多年的杰作。STL的目的是标准化组件，这样就不用重新开发，可以使用现成的组件。STL是C++的一部分，因此不用安装额外的库文件。 序列性容器序列性容器以线性的方式存储元素，它没有对元素进行排序，元素的顺序和存储他们的顺序相同。 array&lt;T,N&gt;：数组容器，一个长度固定的序列，有N个T类型的对象，不能增加和删除元素； vector&lt;T&gt;：向量容器，一个长度可变的序列，用来存放T类型的对象，必要时可以增加容量，但只能在序列的末尾高效的增加和删除元素； deque&lt;T&gt;：双向队列容器，是一个长度可变的、可以自动增长的序列，在序列的两端都不能高效的增加和删除元素； list&lt;T&gt;：链表容器，是一个长度可变的、由 T 类型对象组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素。访问容器中任意元素的速度要比前三种容器慢，这是因为 list&lt;T&gt; 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。 forward list&lt;T&gt;：正向链表容器，是一个长度可变的、由 T 类型对象组成的序列，它以单链表的形式组织元素，是一类比链表容器快、更节省内存的容器，但是它内部的元素只能从第一个元素开始访问。 Vectorvector即变长数组（长度根据需要而自动改变的数组）使用vector，需要添加vector头文件，即#include &lt;vector&gt;。除此之外，还需要在头文件下加上一句using namespace std;这样就可以在代码中使用vector了。 vector定义单独定义一个vector： 1vector&lt;typename&gt; name; 如上定义相当于定义了一个二维数组，name&lt;SIZE&gt;，只不过其长度可以根据需要进行自由变化，比较节省空间。 和一维数组一样，这里的typename可以是任何基本类型，例如：int、double、char、结构体等，也可以是STL标准容器，例如：vector、set、queue等。 注：如果typename也是一个STL容器，定义时需要在&gt;&gt;符号之间加上空格。 12345vector&lt;int&gt; name;vector&lt;double&gt; name;vector&lt;char&gt; name;vector&lt;node&gt; name; // node是结构体的类型vector&lt;vector&lt;int&gt; &gt; name; // 需要在&gt;&gt;之间加上空格 如果联想而二维数组的定义，即其中的一维是数组的组数： 1vector&lt;typename&gt; Arrayname[arraySize]; 那么vector数组也一样，即Arrayname[]中的每一个元素都是一个vector，可以把vector数组当作两个可以变长的二维数组理解。 例如： 1vector&lt;int&gt; vi[100]; 这样vi[0]~vi[99] 中每一个都是一个vector容器。 与vector&lt;vector&lt;int&gt; &gt; name不同的是，这种写法的一维长度已经固定为arraySize，另一维度才是“边长”的数组。 vector元素的访问vector一般有两种访问方式： 通过下标访问 与访问数组一样，对于vector&lt;typename&gt; vi的vector容器来说，直接访问vi[index]即可。 通过迭代器访问 迭代器可以理解为一种类似指针的东西，其定义是： 1vector&lt;typename&gt;::iterator it; 则it就是一个vector&lt;typename&gt;::iterator型的变量，typename可以替换为vector容器的类型，如： 12vector&lt;int&gt;::iterator it;vector&lt;double&gt;::iterator it; 这样就得到了一个迭代器it，并且可以通过*it访问vector里的元素。例如： 1234567891011121314#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int main(){ vector&lt;int&gt; vi; for(int i = 0; i &lt; 5; i++){ vi.push_back(i+1); } for(vector&lt;int&gt;::iterator it = vi.begin(); it != vi.end(); it++){ printf(\"%d \",*it); } return 0;} vector 常用函数实例解析 push_back() 在vector后面添加一个元素，时间复杂度为O(1)。 pop_back() 可以删除vector的尾部元素，时间复杂度为O(1)。 size() 用来获得vector中元素的个数，时间复杂度为O(l)。size()返回的是unsigned类型，不过一般使用%d不会出很大问题，这一点对于所有的STL容器都是一样的。 clear() 用来清空vector中的所有元素，时间复杂度为O(N)，其中N为vector中元素的个数。 insert() insert(it,x)用来向vector的任意迭代器it处插入一个元素x，时间复杂度为O(N)。 1234567891011121314#include &lt;cstdio.h&gt;#include &lt;vector&gt;using namespace std;int main(){ vector&lt;int&gt; vi; for(int i = 1; i &lt;= 5; i++)P{ vi.push_back(i); // 1 2 3 4 5 } vi.insert(vi.begin() + 2, -1); for(int i = 0; i &lt; vi.size(); i++){ printf(\"%d \", vi[i]); // 1 2 -1 3 4 5 } return 0;} erase() 有两种用法： 删除单个元素 erase(it)删除迭代器为it的元素。 删除一个区间的所有元素。 erase（first，last）删除[first,last)内的所有元素。 12345678910111213#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std；int main(){ vector&lt;int&gt; vi; for(int i = 5; i &lt;= 9; i++){ vi.back_push(i); // 5 6 7 8 9 } vi.erase(vi.begin() + 1, vi.begin()+4); // 删除vi[1], vi[2], vi[3] for(int i = 0; i &lt; vi.size(); i++){ printf(\"%d \", vi[i]); // 5 9 }} 注：在使用eraser()时，会将迭代器一并删除，导致不能使用it++来找到下一个元素，此时，可以利用vector.eraser()函数会返回当前被删除迭代器的特性: 123456789for (vector&lt;child&gt;::iterator it = vi.begin(); it != vi.end();){ (*it).num = ++temp; if (*it == 0){ it = vi.erase(it); } else{ it++; } } vector 常见用途 存储数据 vector本身可以作为数组使用，而且在一些元素个数不确定的场合可以很好的节省空间。 有些场合需要把数据输出在同一行，数据中间用空格隔开。由于输出的个数是不确定的，为了方便的处理最后一个满足条件的数据不输出额外的空格，可以用vector记录所有输出的数据，然后一次性输出。 用邻接表存储图 C++ mapmap翻译为映射，在定义数组时（如int array[100]）,其实是定义了一个从int型到int型的映射，比如array[0] = 25就是将0映射到25。无论是double数组还是字符数组都是将int型映射到其他类型，但当需要以其他关键字来做映射时，会显得不太方便，例如字典需要：字符串–&gt;页码的对应关系，这时就可以使用map。 map可以将任何基本类型（包括STL容器）映射到任何基本类型（包括STL容器），也就可以建立string到int的映射。 来看一个情况：需要判断一些数字是否在文件中出现过，按照正常的思路，可以开一个bool型hashTable[max_size]，通过判断hashTable[x]为true还是false来确定x是否在文件中出现过，但是会碰到一个问题，如果这些数字很大（几千位），name这个数组就开不了。而这时就可以使用map，可以把这些数字当成字符串，然后建立string–int的映射（或者直接建立int–int的映射）。 如果使用map需要 12#include &lt;map&gt;using namespace std; map 的定义单独定义一个map： 1map&lt;typename1,typename2&gt; mp; map和其他STL容器有点不一样，因为map需要定义映射前类型（键key）和映射后类型（至value），所以需要在&lt;&gt;内写两个类型，第一个是键类型，第二个是值的类型。如果是int型映射到int型，就相当于普通的int型数组。 而如果是字符串映型映射到整型，必须使用string而不能用char数组： 1map&lt;string,int&gt; mp; 因为char数组作为数组，是不能被作为键值的。 map 容器内元素的访问map有两种访问方式： 通过下标访问 和访问数组是一样的，例如对一个定义为map&lt;char, int&gt; mp的mp来说，可以直接使用mp['c']的方式来访问它对应的整数，于是当建立映射时，就可以使用mp['c']=20这样和普通数组一样的方式。但要注意，map中键值是唯一的： 1234567891011#include &lt;cstdio&gt;#include &lt;map&gt;using namespace std;int main(){ map&lt;char, int&gt; mp; mp['c'] = 20; // 20被覆盖 mp['c'] = 30; printf(\"%d\",mp['c']);} 通过迭代器访问 1map&lt;typename1, typename2&gt;::iterator it; map迭代器使用方式与其他STL迭代器不同，因为map的每一对映射都有两个typename，这决定了必须通过一个it来同时访问键值和值。事实上，map可以使用it-&gt;first来访问键，使用it-&gt;second来访问值。 12345678910111213#include &lt;cstdio&gt;#include &lt;map&gt;using namespace std;int main(){ map&lt;char, int&gt; mp; mp['a'] = 24; mp['d'] = 67; mp['b'] = 55; for(map&lt;char,int&gt;::iterator it = mp.begin(); it != mp.end(); it++){ printf(\"%c %d\\n\", it-&gt;first,it-&gt;second); } } 输出： 123a 24b 55d 67 可以发现，map会以键从大到小的顺序自动排列，即按照a&lt;b&lt;d的顺序自动排列，这是由于map内部的红黑树实现的（同set），在建立映射过程中可以实现从大到小的功能。 map 常用函数实例解析 find() find(key)返回键为key的映射的迭代器，时间复杂度为O(logN) 123456789101112#include &lt;cstdio&gt;#include &lt;map&gt;using namespace std;int main(){ map&lt;char, int&gt; mp; mp['a'] = 24; mp['b'] = 67; mp['d'] = 55; map&lt;char,int&gt;::iterator it = mp.find('a'); printf(\"%d\",it-&gt;second);} erase() 有两种用法 删除单个元素 mp.erase(it) mp.erase(key) 删除一个区间内所有的元素 mp.erase(first,last) — (first,last] — first与last均为迭代器 注：与vector相同,map在使用eraser()方法时，也会存在找不到下一个迭代器的情况，但C++98中map::erase并没有返回值为iterator的原型函数，所以不能仿照vector的写法，在执行map.eraser(it)后,这个迭代器已经失效了，此时可以: 1234567for(map&lt;int,int&gt;::iterator it = mapInt.begin();it != mapInt.end();){ if(it-&gt;second == 0){ mapInt.erase(it++); } else { it++; }} 该方法中利用了后缀++的特点，这个时候执行mapInt.erase(it++);这条语句分为三个过程 先把it的值赋值给一个临时变量做为传递给erase的参数变量 因为参数处理优先于函数调用，所以接下来执行了it++操作，也就是it现在已经指向了下一个地址。 再调用erase函数，释放掉第一步中保存的要删除的it的值的临时变量所指的位置。 size() 获取map映射的对数 clear() 用来清空map的所有元素 map 的常见用途 需要建立字符（字符串）与整数直接映射的题目。 判断大整数或者其他数据是否存在的题目，可以把map当做bool数组来用。 字符串和字符映射。 延伸：map的键值是唯一的，而如果遇到一个键值需要对应多个键值，就只能用multimap，另外，C++ 11中还增加了unordered_map以散列代替map内部红黑树实现，使其可以用来处理只映射而不按key排序的需求，速度比map要快很多。 c++ pair当想要将两个元素，绑在一起作为一个合成元素、又不想因此定义结构体时，使用pair可以方便地作为一个替代品。也就是说，pair实际上可以看作一个内部有两个元素的结构体，且这两个元素的类型是可以指定的，例如： 1234struct pair{ typename1 first; typename2 second;} pair 的定义12#include &lt;utility&gt;using namespace std; 注：由于map的内部实现中涉及pair因此添加map的头文件时会自动添加utility头文件。 pair有两个参数，分别对应first和second的数据类型，他们可以是任意基本数据类型或容器。 1pair&lt;typename1, typename2&gt; name; 因此想要定义参数为string和int类型的pair，就可以使用如下写法： 1pair&lt;string, int&gt; p; 如果想要定义pair是进行初始化，只需要跟上一个小括号，里面填写两个想要初始化的元素即可： 1pair&lt;string, int&gt; p(\"haha\",5); 1make_pair(\"haha\",5); pair 中元素的访问pair中有两个元素，分别是first和second，只需要按正常结构体的方式访问即可。 123456789101112131415#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;string&gt;using namespace std;int main(){ pair&lt;string, int&gt; p; p.first = \"香蕉\"; p.second = 3; cout &lt;&lt; p.first &lt;&lt; \" \" &lt;&lt; p.second &lt;&lt; endl; p = make_pair(\"苹果\",4); cout &lt;&lt; p.first &lt;&lt; \" \" &lt;&lt; p.second &lt;&lt; endl; p = pair&lt;string,int&gt;(\"葡萄\",5); cout &lt;&lt; p.first &lt;&lt; \" \" &lt;&lt; p.second &lt;&lt; endl;} 输出： 123香蕉 3苹果 4葡萄 5 pair 常用函数实例解析两个pair类型数据可以直接使用==、!=、&lt;、&lt;=、&gt;、&gt;=比较大小，比较规则是先以first的大小作为标准，只有当first相等时才去判别second的大小。 pair 的常见用途 用来代替二元结构体及其构造函数，可以节省代码时间 作为map的键值对来进行插入： 123map&lt;string, int&gt; mp;mp.insert(make_pair(\"haha\",5));mp.insert(map&lt;stting,int&gt;(\"haha\",5));","link":"/2019/12/20/C-STL-1/"},{"title":"序/INTRO","text":"在现实断裂的地方 梦，汇成了海 顾城 《弥合》","link":"/2019/01/26/%E5%BA%8F-INTRO/"},{"title":"微信小程序","text":"小程序结构目录 | 配置文件JSON | 视图层View 微信小程序，简称小程序，英文名Mini Program，是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或搜一下即可打开应用。 应用范围：内容/工具小程序、零售小程序、游戏/娱乐小程序等 1. 小程序结构目录小程序框架提供了自己的视图层描述语言WXML与WXSS，以及JavaScript，并在视图层与逻辑层提供了数据传输和事件系统，让开发者能够专注于逻辑。 1.1 与传统Web结构对比 结构 传统Web 微信小程序 结构 HTML WXML 样式 CSS WXSS 逻辑 JavaScript JavaScript 配置 无 JSON 1.2 基本项目目录 pages————————————小程序对应的页面目录 index——————————-首页配置文件 logs———————————子页面配置文件 utills————————————–自己封装的工具函数 app.js——————————-全局js app.json—————————全局配置文件 app.wxss————————–全局样式文件 project.config.json————-整个项目的描述文件，类似node中的package.json 2. 配置文件 JSON一个小程序应用包括最近的两种配置文件，一种是全局的app.json和页面自己的pages.json 注意：配置文件中不能出现注释 2.1 全局配置文件 app.jsonapp.json是当前小程序的全局配置，包括小程序的所有页面路径、界面表现、网络超时时间、底部tab等，普通快速启动项目里的app.json配置 123456789101112{ \"pages\":[ \"pages/index/index\", \"pages/logs/logs\" ], \"window\":{ \"backgroundTextStyle\":\"light\", \"navigationBarBackgroundColor\": \"#fff\", \"navigationBarTitleText\": \"WeChat\", \"navigationBarTextStyle\":\"black\" }} 字段含义： pages字段：用于描述当前小程序的所有页面路径，这是为了让微信客户端知道当前小程序页面定义在哪个目录。 windows字段：定义小程序所有页面的顶部背景颜色，文字颜色定义等。 其他配置项细节可以参考文档 小程序的配置 app.json 。 2.2 页面配置 page.json这里的 page.json 其实用来表示 pages/logs 目录下的 logs.json 这类和小程序页面相关的配置。 如果你整个小程序的风格是蓝色调，那么你可以在 app.json 里边声明顶部颜色是蓝色即可。实际情况可能不是这样，可能你小程序里边的每个页面都有不一样的色调来区分不同功能模块，因此我们提供了 page.json，让开发者可以独立定义每个页面的一些属性，例如刚刚说的顶部颜色、是否允许下拉刷新等等。 其他配置项细节可以参考文档 页面配置 。 3. 视图层 ViewWXML（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。 3.1 数据绑定WXML 中的动态数据均来自对应 Page 的 data。 简单绑定数据绑定使用 Mustache 语法（双大括号）将变量包起来，可以作用于： 内容123456&lt;view&gt;{{ message }}&lt;/view&gt;Page({ data: { message: 'Hello MINA!' }}) 组件属性(需要在双引号之内)123456&lt;view id=\"item-{{id}}\"&gt;&lt;/view&gt;Page({ data: { id: 0 }}) 控制属性(需要在双引号之内)123456&lt;view wx:if=\"{{condition}}\"&gt;&lt;/view&gt;Page({ data: { condition: true }}) 关键字(需要在双引号之内)true：boolean 类型的 true，代表真值。 false： boolean 类型的 false，代表假值。 1&lt;checkbox checked=\"{{false}}\"&gt;&lt;/checkbox&gt; 特别注意：不要直接写 checked=”false”，其计算结果是一个字符串，转成 boolean 类型后代表真值。 运算可以在双括号内进行简单的运算，支持的有如下几种方式： 三元运算1&lt;view hidden=\"{{flag ? true : false}}\"&gt;Hidden&lt;/view&gt; 算数运算12345678&lt;view&gt;{{a + b}} + {{c}} + d&lt;/view&gt;Page({ data: { a: 1, b: 2, c: 3 }}) view中的内容为 3 + 3 + d。 逻辑判断1&lt;view wx:if=\"{{length &gt; 5}}\"&gt;&lt;/view&gt; 字符串运算123456&lt;view&gt;{{\"hello\" + name}}&lt;/view&gt;Page({ data: { name: 'MINA' }}) 数据路径运算123456789&lt;view&gt;{{object.key}} {{array[0]}}&lt;/view&gt;Page({ data: { object: { key: 'Hello ' }, array: ['MINA'] }}) 组合也可以在 Mustache 内直接进行组合，构成新的对象或者数组。 数组123456&lt;view wx:for=\"{{[zero, 1, 2, 3, 4]}}\"&gt;{{item}}&lt;/view&gt;Page({ data: { zero: 0 }}) 最终组合成数组[0, 1, 2, 3, 4]。 对象1234567&lt;template is=\"objectCombine\" data=\"{{for: a, bar: b}}\"&gt;&lt;/template&gt;Page({ data: { a: 1, b: 2 }}) 最终组合成的对象是 {for: 1, bar: 2} 也可以用扩展运算符 ... 来将一个对象展开 12345678910111213&lt;template is=\"objectCombine\" data=\"{{...obj1, ...obj2, e: 5}}\"&gt;&lt;/template&gt;Page({ data: { obj1: { a: 1, b: 2 }, obj2: { c: 3, d: 4 } }}) 最终组合成的对象是 {a: 1, b: 2, c: 3, d: 4, e: 5}。 如果对象的 key 和 value 相同，也可以间接地表达。 1234567&lt;template is=\"objectCombine\" data=\"{{foo, bar}}\"&gt;&lt;/template&gt;Page({ data: { foo: 'my-foo', bar: 'my-bar' }}) 最终组合成的对象是 {foo: 'my-foo', bar:'my-bar'}。 注意：上述方式可以随意组合，但是如有存在变量名相同的情况，后边的会覆盖前面，如： 1234567891011121314&lt;template is=\"objectCombine\" data=\"{{...obj1, ...obj2, a, c: 6}}\"&gt;&lt;/template&gt;Page({ data: { obj1: { a: 1, b: 2 }, obj2: { b: 3, c: 4 }, a: 5 }}) 最终组合成的对象是 {a: 5, b: 3, c: 6}。 注意： 花括号和引号之间如果有空格，将最终被解析成为字符串 123&lt;view wx:for=\"{{[1,2,3]}} \"&gt; {{item}}&lt;/view&gt; 等同于 123&lt;view wx:for=\"{{[1,2,3] + ' '}}\"&gt; {{item}}&lt;/view&gt; 3.2 列表渲染wx:for在组件上使用 wx:for 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。 默认数组的当前项的下标变量名默认为 index，数组当前项的变量名默认为 item 123456789101112&lt;view wx:for=\"{{array}}\"&gt; {{index}}: {{item.message}}&lt;/view&gt;Page({ data: { array: [{ message: 'foo', }, { message: 'bar' }] }}) 使用 wx:for-item 可以指定数组当前元素的变量名， 使用 wx:for-index 可以指定数组当前下标的变量名： 123&lt;view wx:for=\"{{array}}\" wx:for-index=\"idx\" wx:for-item=\"itemName\"&gt; {{idx}}: {{itemName.message}}&lt;/view&gt; wx:for 也可以嵌套，下边是一个九九乘法表 1234567&lt;view wx:for=\"{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}\" wx:for-item=\"i\"&gt; &lt;view wx:for=\"{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}\" wx:for-item=\"j\"&gt; &lt;view wx:if=\"{{i &lt;= j}}\"&gt; {{i}} * {{j}} = {{i * j}} &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; block wx:for类似 block wx:if，也可以将 wx:for 用在&lt;block/&gt;标签上，以渲染一个包含多节点的结构块。例如： 1234&lt;block wx:for=\"{{[1, 2, 3]}}\"&gt; &lt;view&gt;{{index}}:&lt;/view&gt; &lt;view&gt;{{item}}&lt;/view&gt;&lt;/block&gt; wx:key如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 `` 中的输入内容，`` 的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。 wx:key 的值以两种形式提供 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。 保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如： 当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。 如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。 示例代码： 在开发者工具中预览效果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;switch wx:for=\"{{objectArray}}\" wx:key=\"unique\" style=\"display: block;\"&gt; {{item.id}}&lt;/switch&gt;&lt;button bindtap=\"switch\"&gt;Switch&lt;/button&gt;&lt;button bindtap=\"addToFront\"&gt;Add to the front&lt;/button&gt;&lt;switch wx:for=\"{{numberArray}}\" wx:key=\"*this\" style=\"display: block;\"&gt; {{item}}&lt;/switch&gt;&lt;button bindtap=\"addNumberToFront\"&gt;Add to the front&lt;/button&gt;Page({ data: { objectArray: [ {id: 5, unique: 'unique_5'}, {id: 4, unique: 'unique_4'}, {id: 3, unique: 'unique_3'}, {id: 2, unique: 'unique_2'}, {id: 1, unique: 'unique_1'}, {id: 0, unique: 'unique_0'}, ], numberArray: [1, 2, 3, 4] }, switch(e) { const length = this.data.objectArray.length for (let i = 0; i &lt; length; ++i) { const x = Math.floor(Math.random() * length) const y = Math.floor(Math.random() * length) const temp = this.data.objectArray[x] this.data.objectArray[x] = this.data.objectArray[y] this.data.objectArray[y] = temp } this.setData({ objectArray: this.data.objectArray }) }, addToFront(e) { const length = this.data.objectArray.length this.data.objectArray = [{id: length, unique: 'unique_' + length}].concat(this.data.objectArray) this.setData({ objectArray: this.data.objectArray }) }, addNumberToFront(e) { this.data.numberArray = [this.data.numberArray.length + 1].concat(this.data.numberArray) this.setData({ numberArray: this.data.numberArray }) }}) 注意： 当 wx:for 的值为字符串时，会将字符串解析成字符串数组 123&lt;view wx:for=\"array\"&gt; {{item}}&lt;/view&gt; 等同于 123&lt;view wx:for=\"{{['a','r','r','a','y']}}\"&gt; {{item}}&lt;/view&gt; 注意： 花括号和引号之间如果有空格，将最终被解析成为字符串 123&lt;view wx:for=\"{{[1,2,3]}} \"&gt; {{item}}&lt;/view&gt; 等同于 123&lt;view wx:for=\"{{[1,2,3] + ' '}}\"&gt; {{item}}&lt;/view&gt;","link":"/2019/01/29/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"Android开发","slug":"Android开发","link":"/tags/Android%E5%BC%80%E5%8F%91/"},{"name":"BLE开发","slug":"BLE开发","link":"/tags/BLE%E5%BC%80%E5%8F%91/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"微信小程序","slug":"微信小程序","link":"/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"categories":[{"name":"Android开发","slug":"Android开发","link":"/categories/Android%E5%BC%80%E5%8F%91/"},{"name":"BLE开发","slug":"BLE开发","link":"/categories/BLE%E5%BC%80%E5%8F%91/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"微信小程序","slug":"微信小程序","link":"/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]}